{
    "version": "https://jsonfeed.org/version/1",
    "title": "The Workshop",
    "subtitle": "",
    "icon": "https://the-m3chanic.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://the-m3chanic.github.io",
    "items": [
        {
            "id": "https://the-m3chanic.github.io/2024/05/08/R2R-Ready-to-Run-Stomping-WTF/",
            "url": "https://the-m3chanic.github.io/2024/05/08/R2R-Ready-to-Run-Stomping-WTF/",
            "title": "R2R (Ready to Run) Stomping - WTF?",
            "date_published": "2024-05-08T02:39:58.000Z",
            "content_html": "<p>When the topic of executing &quot;hidden&quot; code comes up, one's mind often goes into techniques like process injection, C2 server shenanigans, polymorphic code, etc. But what if I tell you there is a method that can execute code that lies plain and simple in the binary, but you'll never see it?</p>\n<p>Before we get started on the juicy stuff, I'm afraid we'll need to learn some prerequisites first. If you happen to be an expert in the .NET compilation and runtime process, and also know how to read assembly, then I have some great news for you: you can skip past a bunch of stuff I'm about to talk about and jump right into Reversing it (although I'd appreciate you giving it a read for the 3 cans of chocolate milk that went into making this post).</p>\n<p>Okay, so let's jump right into it.</p>\n<h2 id=\"what-is-net\"><a class=\"anchor\" href=\"#what-is-net\">#</a> What is .NET?</h2>\n<p>Essentially, .NET is simply a framework developed by Microsoft. Early on, they realised that having different kinds of languages across different kind of platforms was going to get real messy real soon, so they decided to have a common ground for all of them to exist and thrive on: .NET.<br />\nIt helps to think of it as an abstraction layer. Developers don't have to bother about what platform they're writing their programs for (hardware/software, OS, graphics, optimisation, etc.), they can focus on writing good software, and if that software is capable of running on the .NET framework on one device, it is more than likely it will run on all other devices as well (where .NET is installed, of course). Everything from the different languages to the runtime engine - all come under .NET.</p>\n<p>Now that we've gotten that out of the way</p>\n<h2 id=\"what-are-the-different-ways-of-converting-source-to-machine-code\"><a class=\"anchor\" href=\"#what-are-the-different-ways-of-converting-source-to-machine-code\">#</a> What are the different ways of converting source to machine code?</h2>\n<p>Although I am aware there are tons of ways to &quot;compile&quot; code, this blog post is not about that, so I'm going to oversimplify it. We can broadly categorise this conversion into 3 different categories:</p>\n<ol>\n<li>Compiling (C, C++)</li>\n<li>Interpreting (Python)</li>\n<li>JIT Compiling (Java, C#)</li>\n</ol>\n<p><strong>Compiling</strong> - Turn all of your source code into machine code, and store it that way. Advantage? Code is super-fast, since everything is already in a form understood by your machine, and all necessary optimisations have been performed. Disadvantage? Even a small change in your code will warrant a full re-compile of the code to form a new binary, with new optimisations, which is a time consuming and pretty complex process for larger projects consisting of lots of binaries.</p>\n<p><strong>Interpreting</strong> - Think of this as translator between you and a person that speaks a foreign language, except the person speaking the foreign language is your CPU. There is a layer in the middle that &quot;interprets&quot; each line of your code as it executes in real time, and all checks (except syntax) are performed, and each line is independent of the other. Meaning, if I have a piece of code that looks like this:<br />\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000000000</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;meow&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<p>The line containing the print statement would get interpreted by the translator 1000000000 different times, without it ever knowing it had just done that a couple nanoseconds back. This is an insane waste of time, because it repeating the same process over and over again, with applying 0 optimisations.</p>\n<p>That doesn't sound very nice, no? Why would you <em>not</em> optimise despite knowing that code is being repeated so much?<br />\nThat brings us to the next mode of conversion: JIT Compiling.</p>\n<p><strong>JIT Compiling</strong> - JIT (Just In Time) is a method of compilation, most popularly used by Java (Java Virtual Machine), so I will be taking Java as a reference when explaining this.<br />\nWhen the JVM is running, all methods are compiled in a tiered and on a need-basis. They all start out similar to an interpreter, where the JVM directly reads the bytecode of a single line and executes it. The catch, however, is when a specific unit (called the  <code>CompilerBroker</code>  in the JVM) decides that a method is being invoked very often, it compiles that specific method (known as a &quot;Hot method&quot;) into the next tier of compilation (the  <code>C1</code>  compiler), and then it is profiled (in order to apply further optimisations), and so on. Essentially, it can be thought of a rainbow land between compiling and interpreting, where code is only compiled on a per-need basis.</p>\n<p>So, in order of efficiency - we can arrange the above 3 methods in the following order:<br />\n <code>Compiling &gt;&gt; JIT Compilation &gt;&gt;&gt; Interpreting</code></p>\n<h2 id=\"okay-what-now\"><a class=\"anchor\" href=\"#okay-what-now\">#</a> Okay, what now?</h2>\n<p>Why did I discuss all this, though? Well, .NET happens to be mainly JIT Compiled, and just like how Java has the JVM (Java Virtual Machine), .NET has the CLR (Common Language Runtime) which handles JITting code.</p>\n<p>Through the years, .NET assembly has only contained the IL (Intermediate Language) code, which needs to be compiled and interpreted into its form of native code by the JIT Compiler after the application begins to run. As the .NET framework started expanding its support to more forms of hardware/software platforms, and was capable of building various kinds of applications, a lot of stress was put on Microsoft to improve the performance of the engine as it was the bottleneck for performance of the application as a whole. Some improvements were made, and one such improvement was AOT (Ahead of Time) compiling.</p>\n<h2 id=\"down-to-business\"><a class=\"anchor\" href=\"#down-to-business\">#</a> Down to business</h2>\n<p>There is a specific form of AOT Compiling, supported from .NET Core 3.0+, called R2R (Ready to Run). In this method, code is compiled and kept ahead of time. This kind of takes a lot of the weight off the runtime engine, since a lot of the code need not be compiled at runtime, and the pre-compiled code can be used instead. A lot of the original factors of the binary, like the metadata, and a bunch of old and new headers are required for this method as well (Why is this important? we'll find out).</p>\n<p>This introduces the issue.</p>\n<p>The code compiled ahead of time is obviously more efficient/optimal than the code the JIT engine would generate at runtime, and both of them would be more or less the same regardless. In R2R compiling, IL code is still produced, but it is not JIT compiled because the engine is smart enough to recognise and say, &quot;Hey! This (the compiled version of the code I want to execute) is already present, I can just use that!&quot;. The IL is only present there for our sake, but is never actually used. And this IL is the code that is used by popular decompilers like DnSpyEx/ILSpy to show us what any given .NET binary might be doing.</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image.png\" alt=\"do you see the problem here?\" /></p>\n<p>Are you seeing the issue yet?<br />\n(THE IL CODE WE SEE IS NEVER EVEN BEING USED!!)</p>\n<p>So what is really going on?</p>\n<h2 id=\"reverse-engineering-r2r-stomped-code\"><a class=\"anchor\" href=\"#reverse-engineering-r2r-stomped-code\">#</a> Reverse Engineering R2R Stomped code</h2>\n<p>I will explain with the help of 2 challenges that utilised this very technique:  <code>Trompeloeil</code>  from  <code>Insomni'hack teaser 2024</code> , and  <code>Delirium</code>  from  <code>AOFCTF 24</code>  (the latter being a challenge made by a friend of mine, <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9oZXhhbWluZTIy\">hexamine22</span>, which later inspired me to make this blog).</p>\n<p>Let's take a look at the second one 1st, Delirium.</p>\n<p>Opening up the file in CFF Explorer, and heading over to the  <code>.NET Directory</code> , and checking the offset of the ManagedNativeHeader RVA, we can see that adding 8 and checking the DWORD at that location tells us what kind of format this specific dll was compiled in.</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-1.png\" alt=\"cff explorer delirium\" /></p>\n<p>Opening the same offset (+8) in a hex editor like GHEX, we can see this</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-2.png\" alt=\"delirium ghex\" /></p>\n<p>The part we need to focus on here is to see that the value of the DWORD is 0x00525452 (&quot;RTR&quot;), signifying that this dll was compiled in the Ready to Run format.</p>\n<p>Opening up the decompiled code in ILSpy, we get something very peculiar:</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-3.png\" alt=\"ilspy delirium\" /></p>\n<p>What? Just a md5 hash check for the flag? That doesn't seem right ü§î</p>\n<p>A wise man once said...</p>\n<p><code>When in doubt, read the assembly</code>  (in this case, the IL will suffice)</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-4.png\" alt=\"ilspy assembly delirium\" /></p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-6.png\" alt=\"tom sus\" /></p>\n<p>Hmm, looks odd. Why are there so many  <code>nop</code>  instructions? Something seems wrong here.</p>\n<p>Thankfully, ILSpy has an option to show us Ready to Run assembly code (the one that's pre-compiled) for binaries that are compiled that way, and since our binary is an RTR one, it should be available.</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-7.png\" alt=\"ilspy r2r delirium\" /></p>\n<p>This disassembly is completely different from what the C# decompilation showed us... wtf?</p>\n<p>From this, we can conclude one thing:<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-8.png\" alt=\"bamboozled\" /></p>\n<p>Given that we can read this assembly, there are multiple ways to progress with solving the challenge now.</p>\n<ol>\n<li>Static analysis - Read the disassembly and figure out what is going on (boring ‚ùå)</li>\n<li>Dynamic analysis - Debug and set a breakpoint at the dll main in IDA (or any debugger of your choice, I prefer IDA), and examine variables at runtime (the method we will be following ‚úÖ)</li>\n</ol>\n<p>So how do we do that?</p>\n<p>We can use this reasoning: The binary asks us for input, and that happens from the dll. Unless the input is entered, none of the actual logic happens, we can be sure of that from the disassembly. So, we can run the  <code>Delirium.exe</code>  file, and let it run until it stops and asks us for input - that is when we can be sure that the control flow has switched over to the DLL.</p>\n<p>Let us do that first.</p>\n<p>(Note: If you come across any exceptions being generated when letting the exe run, just pass them to the application. Those are general exceptions that come from control flow switching between different threads in the presence of a debugger)</p>\n<p>Now we need to find our dll main.</p>\n<p>View &gt; Open Subviews &gt; Segments will show us every segment of every file currently loaded<br />\nSearch for  <code>Delirium.dll</code>  among those, and look for the CODE section in those.</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-9.png\" alt=\"ida segments view delirium\" /></p>\n<p>With some quick pwntools, we can grep for the bytes of the first couple of instructions of our dll's main.</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> * </span><br><span class=\"line\"></span><br><span class=\"line\">assembly = <span class=\"string\">&quot;&quot;&quot;push r15</span></span><br><span class=\"line\"><span class=\"string\">push r14</span></span><br><span class=\"line\"><span class=\"string\">push r12</span></span><br><span class=\"line\"><span class=\"string\">push rdi</span></span><br><span class=\"line\"><span class=\"string\">push rsi</span></span><br><span class=\"line\"><span class=\"string\">push rbp&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(asm(assembly))</span><br><span class=\"line\"><span class=\"comment\"># output: b&#x27;AWAVATWVU&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>Once you get to the start of the CODE section of the dll (the 1st one if more than one exist), simply click  <code>Alt+b</code>  in IDA (to search for bytes), and paste  <code>&quot;AWAVATWVU&quot;</code>  (with the quotes, since it's a byte string). Of all the results that show up, click on the one that are present in  <code>Delirium.dll</code> .</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-10.png\" alt=\"search view results\" /></p>\n<p>Double-clicking will lead you to a bunch of bytes, but that is only because IDA is interpreting those bytes as data, and not code. To tell it to read them as code, put your mouse over there and hit C (convert to code).</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-11.png\" alt=\"undefined code\" /></p>\n<p>After hitting c</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-12.png\" alt=\"make code\" /></p>\n<p>And to be able to decompile this assembly, IDA needs to see this code block as a function, so place your cursor at the start of the code block, and hit P (mark start of function).</p>\n<p>Then you should be able to decompile.</p>\n<p>Although, since none of the symbols are resolved, we won't know the names of the native libraries being called, so we'll have to make sense of things for ourselves.</p>\n<p>After a bit of debugging and reversing, we can find that this challenge is pretty easy - it takes your input, XORs it with a predefined text, and multiplies it with another matrix and checks with a predefined matrix. Pretty simple stuff to reverse.</p>\n<p>Now, we seem to have a fixed way of dealing with binaries like this, here's a recap:</p>\n<ul>\n<li>Confirm R2R mode through offset</li>\n<li>Open up in ILSpy</li>\n<li>Grab bytes of starting few instructions of &quot;stomped code&quot;</li>\n<li>Run binary in IDA until it stops for input</li>\n<li>Locate dll segment in IDA</li>\n<li>Search for said bytes in IDA</li>\n<li>Mark code</li>\n<li>Mark function</li>\n<li>Decompile</li>\n<li>Profit!</li>\n</ul>\n<h2 id=\"asserting-dominance-over-r2r-compiled-binaires\"><a class=\"anchor\" href=\"#asserting-dominance-over-r2r-compiled-binaires\">#</a> Asserting dominance over R2R compiled binaires</h2>\n<p>Let us try this approach on another binary,  <code>Trompeloeil</code>  from  <code>Insomni'hack teaser 2024</code></p>\n<p>First, grab the offset<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-13.png\" alt=\"cff explorer trompeloeil\" /></p>\n<p>Next, check if it's in &quot;RTR&quot; mode<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-14.png\" alt=\"ghex trompeloeil\" /></p>\n<p>(Note: You can also do a quick confirmation to make sure things look suspicious, like here for example)<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-15.png\" alt=\"assembly trompeloeil\" /><br />\nToo many nops, like last time</p>\n<p>Grab the first few bytes of the function<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-16.png\" alt=\"trompeloeil asm \" /></p>\n<p>Look for the CODE section of the dll segment in IDA<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-17.png\" alt=\"dll sections ida trompeloeil\" /></p>\n<p>Start your search from there.<br />\nMost likely, you'll have multiple results, but only one that corresponds to your dll, catch that one<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-18.png\" alt=\"search view results trompeloeil\" /></p>\n<p>Convert to code (hit C)<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-20.png\" alt=\"make code trompeloeil\" /></p>\n<p>Mark as function (hit P)<br />\n<img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/image-21.png\" alt=\"make function trompeloeil\" /></p>\n<p>Decompile!</p>\n<p>Congratulations, you have successfully Reverse-Engineered an R2R obfuscated binary. You can give yourself <em>upto</em> 2 pats on the back.</p>\n<p><img data-src=\"/images/post_images/R2R-Ready-to-Run-Stomping-WTF/imagex.png\" alt=\"alt text\" /></p>\n<p>All in all, this is an interesting and novel way to hide what you're doing in your .NET binary. Very fascinating approach, and if you guys have any doubts with regards to anything I've mentioned here - you can always reach on <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS90aGVfbTNjaGFuaWNf\">Twitter</span>. Cheers.</p>\n",
            "tags": [
                "Technical",
                "R2R",
                "Security",
                "C#",
                ".NET"
            ]
        }
    ]
}