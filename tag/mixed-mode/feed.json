{
    "version": "https://jsonfeed.org/version/1",
    "title": "The Workshop",
    "subtitle": "",
    "icon": "https://the-m3chanic.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://the-m3chanic.github.io",
    "items": [
        {
            "id": "https://the-m3chanic.github.io/2025/07/16/avernos-bi0s-CTF-2025/",
            "url": "https://the-m3chanic.github.io/2025/07/16/avernos-bi0s-CTF-2025/",
            "title": "avernos - bi0s CTF 2025",
            "date_published": "2025-07-16T22:09:33.000Z",
            "content_html": "<p><strong>tl;dr</strong></p>\n<ul>\n<li>Mixed mode assembly (a feature of .NET binaries), involving both C# as well as C++ code in the same executable</li>\n<li>Code flow jumps between both C#/C++ frequently to make analysis harder</li>\n<li>SEH mechanism triggered in C++ code, which uses SEH trampoline to make debugging harder</li>\n<li>SEH triggered once again in C#, which is handled by C++</li>\n<li>VM bytecode is decrypted loaded by C#</li>\n<li>VM checks input in 4 ways: CRC32 hash (2 byte pairs), RC4 encryption, rolling XOR and byte by byte checks</li>\n</ul>\n<p><strong>Challenge Points</strong>: 838<br />\n<strong>No. of solves</strong>: 18<br />\n<strong>Challenge author</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf\">the.m3chanic</span></p>\n<h2 id=\"challenge-description\"><a class=\"anchor\" href=\"#challenge-description\">#</a> Challenge Description</h2>\n<p><code>An ancient engine stirs in the dark. It speaks no language you know.</code></p>\n<h3 id=\"prelude\"><a class=\"anchor\" href=\"#prelude\">#</a> Prelude</h3>\n<p>[Note: I will be showing you the author mindset, on how one can approach such a challenge - this will not be a very ctf-style writeup, but more of a teaching process]</p>\n<p>After reading this writeup, you will (hopefully) be able to:</p>\n<ul>\n<li>Identify and analyse Mixed Mode .NET samples</li>\n<li>Reverse Engineer a custom Virtual Machine</li>\n</ul>\n<h2 id=\"analysis\"><a class=\"anchor\" href=\"#analysis\">#</a> Analysis</h2>\n<p>I will be splitting this writeup into 3 main parts:</p>\n<ul>\n<li>What is mixed mode assembly?</li>\n<li>Reversing mixed mode samples (using this challenge as an example)</li>\n<li>The VM</li>\n</ul>\n<p>Before jumping into reading this, I would suggest some prerequisite reading on the following topics:</p>\n<ul>\n<li>What is .NET? (<a href=\"https://the-m3chanic.github.io/2024/05/08/R2R-Ready-to-Run-Stomping-WTF/\">My blog which explains it</a>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9mcmFtZXdvcmsvZ2V0LXN0YXJ0ZWQvb3ZlcnZpZXc=\">Microsoft reference</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2NzaGFycC9jb21tZW50cy8xN3B1N2Z4L2Nhbl9hbnlvbmVfZXhwbGFpbl93aGF0X2lzX25ldC8=\">Reddit</span>)</li>\n<li>What are &quot;managed&quot; and &quot;native&quot; methods? (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL0BEZXZDaHkvbWFuYWdlZC12cy11bm1hbmFnZWQtY29kZS1lY2VmM2FmZjJkNjU=\">Medium post</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9zdGFuZGFyZC9tYW5hZ2VkLWNvZGU=\">Microsoft reference</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvbWFuYWdlZC1jb2RlLWFuZC11bm1hbmFnZWQtY29kZS1pbi1uZXQv\">GFG</span>)</li>\n</ul>\n<h2 id=\"mixed-mode-assembly\"><a class=\"anchor\" href=\"#mixed-mode-assembly\">#</a> Mixed mode assembly</h2>\n<h3 id=\"what-is-mixed-mode-assembly\"><a class=\"anchor\" href=\"#what-is-mixed-mode-assembly\">#</a> What is mixed mode assembly?</h3>\n<p>A <em>mixed mode assembly</em> in .NET refers to a compiled binary that contains both <strong>managed</strong> as well as <strong>unmanaged</strong> code. To break that down:</p>\n<ul>\n<li><strong>Managed code</strong> is the code that runs under the control of the .NET Common Language Runtime (CLR). Examples of this include C# or <span class=\"exturl\" data-url=\"aHR0cDovL1ZCLk5FVA==\">VB.NET</span> code</li>\n<li><strong>Unmanaged code</strong> is code that runs directly on the Windows OS without the CLR's oversight, and this is typically written in C/C++</li>\n</ul>\n<h3 id=\"why-use-mixed-mode\"><a class=\"anchor\" href=\"#why-use-mixed-mode\">#</a> Why use mixed mode?</h3>\n<p>Functionally, there are many beneficial use cases of having both managed as well as unmanaged code in the same binary. Some of them include:</p>\n<ul>\n<li>interoperability between the two modes</li>\n<li>Optimising performance-critical sections of managed code (C++ runs way faster than managed code)</li>\n<li>Leveraging existing code by taking advantage of interoperability between managed and unmanaged code</li>\n</ul>\n<p>They are enabled using C++/CLI (Common Language Infrastructure), which allows C++ to interoperate directly with .NET classes. This allows you to write native code as well as managed code in the same project and even in the same source file.</p>\n<h3 id=\"how-does-it-work-under-the-hood\"><a class=\"anchor\" href=\"#how-does-it-work-under-the-hood\">#</a> How does it work under the hood?</h3>\n<p>Mixed mode assemblies are unique because they satisfy two very different runtime expectations simultaneously: the native Windows loader and the .NET CLR. How does this work in practice though?</p>\n<ul>\n<li>A mixed mode binary is still a standard PE file</li>\n<li>It contains both:\n<ul>\n<li>Native sections:  <code>.text</code> ,  <code>.data</code> ,  <code>.rdata</code> , etc., compiled from C++</li>\n<li>Managed metadata: a CLR header, metadata tables, and IL bytecode (if present)</li>\n</ul>\n</li>\n<li>When the OS loads the binary, it sees the native entry point ( <code>WinMain</code> ) and begins execution like a regular native application</li>\n<li>Simultaneously, because the PE includes a CLR header and its metadata, the .NET runtime is also initialised and loaded via the  <code>_CorExeMain</code>  or  <code>_CorDllMain</code> , depending on whether it's an EXE or DLL</li>\n</ul>\n<h3 id=\"loader-behaviour\"><a class=\"anchor\" href=\"#loader-behaviour\">#</a> Loader behaviour</h3>\n<ul>\n<li>The Windows PE loader first processes the native parts. This allows the mixed mode assembly to include custom startup routines written in native code</li>\n<li>Usually, this begins with  <code>mainCRTStartup</code> , which is the standard C runtime startup stub generated by the MSVC toolchain. This stub sets up the runtime environment, initialises global variables, and eventually calls  <code>main</code> ,  <code>WinMain</code> , or  <code>wWinMain</code>  - depending on the system</li>\n<li>In a mixed mode assembly, this native entry point might call  <code>_CorExeMain</code> , which is responsible for bootstrapping the CLR</li>\n<li>These two systems <em>coexist in the same process space</em>, which is what makes mixed mode so difficult to analyse</li>\n</ul>\n<p><strong>Note</strong>: Not all mixed mode binaries use  <code>mainCRTStartup</code>  directly. Some may use a custom entry point or modified CRT startup to gain more control over execution flow. However, in most cases compiled via standard C++/CLI,  <code>mainCRTStartup</code>  is the default native entry point.</p>\n<ul>\n<li>Functions written in managed code can call native functions using <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke\"> <code>P/Invoke</code> </a> or  <code>DllImport</code>  attributes</li>\n<li>Native code compiled with C++/CLI can directly reference and instantiate managed types</li>\n<li>This means the transition between C# and C++ isn’t just at a function-level - it can go as deep as shared objects and class methods</li>\n</ul>\n<p>In essence, mixed mode assemblies live in both worlds simultaneously. They can present a well behaved .NET facade while hiding all the juicy logic and the humble malware code on the native side (which are completely opaque to most .NET tools).</p>\n<h2 id=\"reversing-a-mixed-mode-sample\"><a class=\"anchor\" href=\"#reversing-a-mixed-mode-sample\">#</a> Reversing a Mixed Mode sample</h2>\n<p>So let us begin analysis of this sample as we would for any binary - starting from how you would even identify whether a sample is mixed-mode or not.</p>\n<p>Running  <code>file</code>  on the sample tells us it's a  <code>x86-64 Mono/.NET assembly</code>  file<br />\n<img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image.png\" alt=\"output of the file command\" /></p>\n<p>This does not wave any red flags, just tells us this binary has managed code. Nothing too special.</p>\n<p>One thing I like to do to get this confusion out of the way always is to open the binary in a PE-inspection tool like <a href=\"https://ntcore.com/explorer-suite/\"> <code>CFF Explorer</code> </a>, and check out if it has a IL entry point or not.<br />\nThe way to do this is to check the  <code>Flags</code>  section in the  <code>.NET Directory</code>  of the binary (I am using CFF Explorer).</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-1.png\" alt=\"cff explorer output\" /></p>\n<p>Check out the 2 flags I've highlighted, these say right off the bat that:</p>\n<ul>\n<li>The binary contains stuff which is <em>not</em> IL code</li>\n<li>The binary does <em>not</em> have a native entrypoint<br />\nWhich means: The binary contains native code and it's startup is in the managed code (which is most definitely  <code>mainCRTStartup</code> )</li>\n</ul>\n<p>Now that we know where the code execution is about to begin, let's open up the binary in a .NET decompiler (I prefer dnSpy for these).</p>\n<p>Another dead giveaway that this binary contains native code is the existence of CPP metadata as shown in dnSpy<br />\n<img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-2.png\" alt=\"dnSpy cpp metadata\" /></p>\n<p>Looking for  <code>mainCRTStartup</code>  in dnSpy:</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-3.png\" alt=\"mainCRTStartup\" /></p>\n<p>Okay, three terms to note before we proceed:</p>\n<h3 id=\"token\"><a class=\"anchor\" href=\"#token\">#</a> Token</h3>\n<ul>\n<li>A unique identifier given to every metadata object (like a method, type, field, etc.)</li>\n<li>A 4-byte value where:\n<ul>\n<li>The high byte indicates the metadata table type</li>\n<li>The low 3 bytes indicate the row index in that table</li>\n</ul>\n</li>\n<li>In our case:  <code>0x0600005D</code> :\n<ul>\n<li><code>0x06</code>  -&gt;  <code>MethodDef</code>  table (all method definitions) (<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnRjb3JlLmNvbS9maWxlcy9kb3RuZXRmb3JtYXQuaHRt\">Source</span>)</li>\n<li><code>0x00005D</code>  -&gt; Row index  <code>0x5D</code></li>\n</ul>\n</li>\n<li>More of this info can be found within  <code>ILDasm</code>  or  <code>dnSpy</code>  itself</li>\n</ul>\n<h3 id=\"rid\"><a class=\"anchor\" href=\"#rid\">#</a> RID</h3>\n<ul>\n<li>This is shorthand for the row index inside the metadata table</li>\n<li>It's the &quot;number&quot; part of the token</li>\n</ul>\n<h3 id=\"rva\"><a class=\"anchor\" href=\"#rva\">#</a> RVA</h3>\n<ul>\n<li>Relative Virtual Address, is the offset (in memory) from the /images/post_images/avernos-bi0s-CTF-2025/image base (typically  <code>0x14000000</code> ) to the method's actual compiled code in the PE's  <code>.text</code>  section</li>\n<li>This is where the JIT compiler (or loader) will find the native stub or unmanaged entry point</li>\n<li>If you open the binary in IDA/Ghidra/Binary Ninja, and go to the offset  <code>0x4464</code> , you will find the implementation of the method/function.</li>\n</ul>\n<h3 id=\"file-offset\"><a class=\"anchor\" href=\"#file-offset\">#</a> File Offset</h3>\n<ul>\n<li>The raw byte offset in the file where this method's code resides on the disk</li>\n<li>This is useful when:\n<ul>\n<li>Looking at the binary in a hex editor</li>\n<li>Manually extracting or patching bytes</li>\n<li>Mapping RVA to file offset via PE Header section tables</li>\n</ul>\n</li>\n</ul>\n<p>So now we know the address of the  <code>mainCRTStartup</code>  method in the native section, it is simply the base address of the loaded /images/post_images/avernos-bi0s-CTF-2025/image in IDA + the  <code>RVA</code>  of the method as shown by dnSpy.</p>\n<p>Now, one thing to note when loading it in a native decompiler/disassembler is to specify to your tool to load it as a  <code>PE</code>  file as compared to a  <code>Microsoft.Net assembly</code>  file.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-4.png\" alt=\"ida pick which file type\" /></p>\n<p>Now, hit  <code>G</code>  to be able to jump to any address, and paste the  <code>base_addr + RVA</code>  value into the field. (Find the base address from  <code>Edit -&gt; Segments -&gt; Rebase Program</code> , and copy the  <code>Value</code>  field from there - for me, the base is  <code>0x140000000</code> ).<br />\nSo the address to jump to, would be  <code>0x140004464</code></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-5.png\" alt=\"mainCRTStartup\" /></p>\n<p>And just like that, we have our &quot;main&quot; (well, not really)<br />\nIn standard Windows fashion, we need to do a <em>little</em> more digging before we actually find the main code. The first function called usually only performs setup for the actual code to run, which would be the one being returned.</p>\n<p>Similarly, in the next function - look for the 2nd to last function being called after  <code>argv</code> ,  <code>argc</code>  and  <code>envp</code>  are initialised. For us, that would be the function at  <code>0x140003BA0</code>  (line 58 in my decompilation).</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-6.png\" alt=\"argv and argc setup\" /></p>\n<p>Finally, we can start analysing the actual  <code>main</code>  function of the binary.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-7.png\" alt=\"actual main\" /></p>\n<p>From some looking, the function at  <code>0x140003DD8</code>  seems to initialise an array with some unknown values, copies that to the argument passed, then returns it. This return value is then passed to the next function.<br />\nBut if we look at  <code>0x140007070</code> , it just seems to be pointing to some  <code>qword</code>  value, which resolves to  <code>0x6000011</code>  - what could this be?<br />\nThis is actually the  <code>Token</code>  of the method being called from C++ -&gt; C#, and we can use this as a lookup value to find the actual function in C# being referenced.</p>\n<p>If we hop back to dnSpy, and lookup that value in the same  <code>&lt;Module&gt;</code>  place we looked at before, we see this</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-8.png\" alt=\"c# decrypt function\" /></p>\n<p>We can see this performs a XOR decrypt of the byte array provided to it and returns the corresponding result to  <code>v1</code> , which is meant to be a file which is to be opened in read mode, and the file descriptor returned to  <code>v5</code> .<br />\nThe path of the file returned is  <code>/home/the.m3chanic/bi0s-ctf-25/crazy-path/hehe/flag.txt</code>  - which is obviously not going to exist on a given machine. Let us see how this file descriptor is being further used.</p>\n<p>In the remnant of the function, we can see  <code>func2(fd)</code>  is being called with the file descriptor of the  <code>flag.txt</code>  file (which, does not exist btw), which again points to the TID  <code>0x6000009</code> , which if we lookup in dnSpy gives us</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-9.png\" alt=\"dnspy func2 first c# trigger exception\" /></p>\n<p>[I wrote this writeup over multiple days, and it seems my IDA database decided to rebase itself to a different address, the concept of mapping a function from dnSpy to a native decompiler still remains the same though! You can refer to this updated base address hereon:  <code>0x7FF7DF220000</code> ]</p>\n<p>It seems to set up some values, and then XORs something and then divides them with the value it was passed as a parameter. Now we know this value is  <code>0</code>  on our machine, but wouldn't that cause a  <code>DivideByZero</code>  exception?<br />\nLet us take a look at the assembly when  <code>func2(fd)</code>  is being called.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-10.png\" alt=\"try except for func2 call\" /></p>\n<p>Aha! So it is being set up inside a  <code>try</code>  block, and the exception handler for that block is present at  <code>0x7FF7DF223C27</code> , let us see what happens there.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-11.png\" alt=\"first exception handler chain asm\" /></p>\n<p>So as we can see, in the exception handler for our first exception, it is calling a function at  <code>0x7FF7DF22188C</code> , and based on the return value it either exits from the main function or it enters our 2nd interesting block - so it is definitely worth checking out.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-12.png\" alt=\"first anti debug check\" /></p>\n<p>This is a classic anti-debug check, wherein it tries to open the file of the current process. Usually, debuggers read the debug information of the process from the file - and if this handle is not closed then the process cannot open this file - meaning that a failed call indicates the presence of a debugger.</p>\n<p>To bypass this, we can just patch out the call to this anti-debug function with  <code>nops</code>  and patch the  <code>jz</code>  to a  <code>jmp</code> .</p>\n<p>The 2nd block is quite easy as well - it calls  <code>rand()</code> , xors the result with itself and calls  <code>rand()</code>  again and attempts to divide the result with the result of the previous xor (which would be 0) - thus causing a  <code>DivideByZero</code>  exception yet again.<br />\nIf you observe closely, even this 2nd block is wrapped in a  <code>try</code> , which means our  <code>except</code>  (at  <code>0x7FF7DF223C67</code> ) must be where we should look.</p>\n<p>Looking at the block, it calls  <code>0x7FF7DF221924</code>  - which has the same routine as the 2nd interesting block, which again has the same routine - which eventually calls  <code>func6()</code> .</p>\n<p>What we just witnessed in assembly is what I would call a trampoline of sorts. It looks something like this in pseudocode:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        trampoline2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        trampoline3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        func6();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The way to bypass such exception checks is to identify the address of the handler (in our case, the  <code>__except</code>  block) and set a breakpoint there. Then, let your debugger run and when the exception occurs - pass it to the application instead of letting the debugger handle it. This is the standard way to handle <em>most</em> exception handler checks.</p>\n<p>Again,  <code>func6</code>  has the token  <code>0x6000006</code> , let us inspect that in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-14.png\" alt=\"func6 and func8 in dnspy\" /></p>\n<p>Finally! Some actual stuff.</p>\n<p>This function seems pretty straightforward, too. Asks for user input in the pattern  <code>bi0s&#123;...&#125;</code>  and extracts the content within the flag format.<br />\n <code>func8()</code>  is then called with that input as a parameter.<br />\n <code>func8()</code>  does nothing but inject the extracted input into the input stream.</p>\n<p>It also calls  <code>func1()</code></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-15.png\" alt=\"func1 dnSpy decompilation\" /></p>\n<p>(I may have forgotten to remove the names of some of the symbols, so this part accidentally gave away the fact that this is a VM ☠️ nevertheless let us proceed as if we do not know it and see how we can identify one naturally)</p>\n<p>It:</p>\n<ul>\n<li>Checks to see if a variable  <code>global_flag</code>  is set to 1 or not, and exits depending on that</li>\n<li>Calls  <code>decrypt_embedded_instructions()</code></li>\n<li>Calls  <code>func5()</code></li>\n<li>Calls  <code>run_vm()</code></li>\n<li>Based on the result of  <code>run_vm()</code> , will print either of 2 things (which we can guess will be something along the lines of &quot;true&quot; or &quot;false&quot;)</li>\n</ul>\n<p>Let's break these down step by step.</p>\n<p><code>global_flag</code>  is defined at the RVA  <code>0x191B0</code> , which in IDA maps to a global variable. You xref that, you find it is referenced once at a function whose RVA is  <code>0x1880</code> . You can look up this RVA now in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-17.png\" alt=\"0x1880 func1() lookup in dnSpy\" /></p>\n<p>Right click -&gt; Analyse  <code>func11()</code> , and you can find cross references to that function in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-18.png\" alt=\"func11 used by\" /></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-19.png\" alt=\"func6 calling func11\" /></p>\n<p>We can see that our main logic function (which, if you recall occurs right after an anti-debug check), is benignly setting this variable. No biggie.</p>\n<p>Let's take a look at what  <code>decrypt_embedded_instructions()</code>  does.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-16.png\" alt=\"decrypt_embedded_instructions dnSpy\" /></p>\n<p>It seems to be taking an array  <code>embedded_instructions</code> , and performing the following operation on it:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">embedded_instruction[i] ^= <span class=\"number\">66</span>;</span><br><span class=\"line\">embedded_instruction[i] = ROR(embedded_instruction[i], <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// where ROR() is rotate right </span></span><br></pre></td></tr></table></figure></p>\n<p>Then,  <code>func5()</code>  seems to be defined natively, so we can take a look at that next</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-20.png\" alt=\"load vm bytes function\" /></p>\n<p>This function seems to be copying bytes from the first argument passed, to a global array. The array passed is  <code>embedded_instructions</code> , which was just previously decrypted. A counter seems to be incremented for each loop iteration - let's call that  <code>unc_counter</code>  for now. Although we do know it'll contain the total number of instructions present in the VM.</p>\n<p>Aaand next up, we have  <code>run_vm()</code> , which is going to be our key function to reverse. It is defined at the RVA  <code>0x161C</code> .</p>\n<p>A quick recap before we proceed:</p>\n<ul>\n<li>Some anti-debug checks (using the  <code>CreateFileW</code>  API and SEH)</li>\n<li>User input taken in C# using regex, which is injected into the input stream</li>\n<li>Global flag is set to true</li>\n<li>Another exception trigger from C#, which is handled in C++ then handed back to C#</li>\n<li>An unclear array is decrypted and loaded into a global buffer</li>\n<li>A function  <code>run_vm()</code>  is called</li>\n</ul>\n<h2 id=\"the-vm\"><a class=\"anchor\" href=\"#the-vm\">#</a> The VM</h2>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-21.png\" alt=\"vm setup func\" /></p>\n<p><code>0x7FF7DF221530</code>  sets that memory region to 0.<br />\nIf we look closely at the function defined at  <code>0x7FF7DF221570</code> ,</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-22.png\" alt=\"fetch instruction by counter\" /></p>\n<p>We can see there is a loop being run whose iteration count is the number of instructions loaded into  <code>embedded_instructions</code> . It is loading each element (7 bytes long) from the array, and passing those 7 bytes into a function at  <code>0x7FF7DF221540</code>  and checking its return value against something.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-23.png\" alt=\"alt text\" /></p>\n<p>This returns a  <code>WORD</code>  (16 bit) value in the format  <code>[byte_0 &lt;&lt; 8 | byte_2]</code> . Generally, when we see such weird indices being indexed (especially from a 7 byte long value?), it indicates that the value being indexed might be a structure - and these are members of the structure being accessed.<br />\nSo assuming that it <em>is</em> a structure, we can proceed with a simple structure definition as follows:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unc_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem1;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem2;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem3;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem4;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem5;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem6;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem7;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>After changing all relevant occurances of 7 byte arrays to this structure, we can now continue analysis of this function.<br />\nThere is only function call left, which is to  <code>0x7FF7DF221EAC</code> , which takes the memory region previously initialised to 0 and the return value of the previously called function.</p>\n<p>Frankly, there's quite a bit to grasp in this function - lots of weird memory accesses and a ton of cases to analyse. A good practice to follow in cases like these is to see if you can find a pattern/generalise the instructions and see if they're performing something at a higher level.</p>\n<p>Let us see what patterns we can figure out at first glance from this mammoth function:</p>\n<ul>\n<li>The same functions being reused in a lot of places (e.g:  <code>0x7FF7DF2210B0</code> ,  <code>0x7FF7DF2211F0</code> ,  <code>0x7FF7DF221370</code> ,  <code>0x7FF7DF221170</code> ,  <code>0x7FF7DF2211B0</code> ,  <code>0x7FF7DF221230</code> ,  <code>0x7FF7DF221330</code> ,  <code>0x7FF7DF2212F0</code> ,  <code>0x7FF7DF221550</code> ). These might seem like a lot but it's just 9 or 10 functions to reverse which are virtually being used in every case - so if you rev these you rev this entire mammoth!</li>\n<li>A lot of simple arithmetic being performed in each individual case - indicating that this function might be a virtual machine</li>\n<li>The same &quot;control variables&quot; being used in a lot of places - i.e, these variables are used to determine the return values of many functions</li>\n</ul>\n<p>With this in mind, let us start analysing those repetetive functions one at a time.</p>\n<p>(I've renamed each of the functions in the list above in the format  <code>func_&#123;i&#125;_unc</code> )</p>\n<p>If you look at each of the functions in the list above, you will notice a few more patterns. Let us go through each of them here.</p>\n<p><code>unc_mem_buf</code>  being passed as the 1st parameter, and  <code>elem5</code>  being passed as the 2nd parameter. The function uses  <code>elem5</code>  as a &quot;control variable&quot; to pick and return a value from the  <code>unc_mem_buf</code> .</p>\n<p>The list of functions that matches this criteria is:</p>\n<ul>\n<li><code>func_1_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>char *</code>  and returns 1 of any 10 bytes from the 0th-10th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_4_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>short int *</code>  and returns 1 of any 5  <code>words</code>  from the 10th-20th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_5_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>int *</code>  and returns 1 of any 5  <code>ints</code>  from the 20th-40th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_2_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>long long int *</code>  and returns 1 of any 5  <code>qwords</code>  from the 40th-80th indices of  <code>unc_mem_buf</code></li>\n</ul>\n<p>We can confidently rename the above 4 functions to  <code>select_byte</code> ,  <code>select_word</code> ,  <code>select_dword</code>  and  <code>select_qword</code>  respectively.</p>\n<p>It is highly risky to define a structure without knowing its size first. However, from the previous function we know that the size of  <code>unc_mem_buf</code>  is  <code>4466</code>  bytes. So we can define a structure with what we know so far, and leave the rest as  <code>pad</code> .</p>\n<p>If we analyse the usage of the return values from the above - we can see that these are being used in the operations that we noticed earlier which hinted at this function potentially being a VM.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-28.png\" alt=\"alt text\" /></p>\n<p>A similar case for the other functions as well. This indicates that those return values are potentially &quot;registers&quot; that are being used inside our VM, meaning that the  <code>select_*</code>  functions we uncovered earlier are in fact functions to select a register from our VM.</p>\n<p>If we were to define this in a strucure now, it would look a little something like:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_1;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_2;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_3;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_4;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_5;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_6;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_7;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_8;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_9;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_10;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> pad[<span class=\"number\">4386</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nIt would also be a good idea at this point to rename  <code>unc_mem_buf</code>  to  <code>vm_state</code> .</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-29.png\" alt=\"alt text\" /><br />\nLooks much cleaner now! Let us continue our analysis.</p>\n<p>So considering that this is a VM - we've found the registers and the functions that select them - obviously there should also be ones that set them, right? Analysing the rest of the  <code>func_*_unc</code>  functions, seems like those are it.<br />\nAn additional element in these functions would be the value to &quot;set&quot; the register to, so let's keep a look out for those too.</p>\n<p>After similar analysis as before and some type fixing:</p>\n<ul>\n<li><code>func_3_unc</code>  -&gt;  <code>set_q_register</code></li>\n<li><code>func_6_unc</code>  -&gt;  <code>set_b_register</code></li>\n<li><code>func_7_unc</code>  -&gt;  <code>set_d_register</code></li>\n<li><code>func_8_unc</code>  -&gt;  <code>set_w_register</code></li>\n</ul>\n<p>I've also renamed the &quot;selection&quot; functions in a similar format, i.e,  <code>get_*_register</code></p>\n<p>The entire function looks a lot cleaner and more understandable now. It is a clear cut VM. Let us note some more interesting points from further analysis:</p>\n<ul>\n<li><code>vm_state-&gt;pad[0]</code>  is consistently used in bitwise assignments and comparisons, which indicates it might be some kind of a &quot;flag&quot; register. Let us rename it to  <code>eflags</code>  (x86 standard)</li>\n<li><code>v68</code>  (the return value of the function at  <code>0x7FF7DF221CF0</code> ) seems to be the main control point of the entire VM, indicating it might be the opcode. This means we would need to analyse how that is being generated.</li>\n<li>In the cases that <em>do</em> use the (now)  <code>eflags</code>  register, we can see there is a particular function being called in each one: named  <code>func_9_unc</code> . Usually,  <code>eflags</code>  is only checked in the case of  <code>jmp</code>  instructions.</li>\n<li>There are some yet-to-be defined functions. Upon some inspection, these seem like they are taking a value as an argument, and placing those in a buffer that is part of the  <code>vm_state</code> . These are nothing but memory write/memory read instructions.</li>\n</ul>\n<p>We do not have enough context to fully understand  <code>func_9_unc</code>  yet, so let us switch and look at how that opcode is formed.</p>\n<p>It takes  <code>elem2</code>  and  <code>elem4</code>  from our struct, and passes it to some function defined in C#.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-30.png\" alt=\"decrypt block cipher\" /></p>\n<p>So the first param is some  <code>key</code> , and the second is the  <code>ciphertext</code> . Does this mean that each &quot;instruction&quot; (7 byte) is storing the real opcode with the encrypted opcode as well as the key to decrypt it, embedded inside? Let us update the structure with the same.</p>\n<p><code>elem5</code>  and  <code>elem6</code>  in the struct seem to be used as arguments in almost every case in the VM. These might just be the operands for the instruction. Let us change those too.</p>\n<p>Now, for another important function:  <code>0x7FF7DF221540</code> . This is called twice in the entire binary, once in the VM function, and again when deciding which instruction gets executed next in the VM. So let us take a look.</p>\n<p>For the function that calls it ( <code>0x7FF7DF221570</code> ), the 2nd argument passed to it is the global variable at  <code>0x7FF7DF2391B4</code> , which is interestingly incremented after each time the VM function executes, so it might be some kind of program counter.</p>\n<p>That function simply returns a packed form of  <code>elem1</code>  and  <code>elem3</code>  in the structure. This seems to be the control point for determining which instruction among all the instructions are to be executed. This could be some kind of value that indicates the &quot;index&quot; of the instruction present in memory, which indicates the order in which they are to be executed.</p>\n<p>Keeping all this in context, revisiting  <code>func_9_unc</code>  gives us a better idea of its working: it simply calculates the &quot;address&quot; (or in this context, the <em>index</em>) of the next instruction to be executed. It is the VM's  <code>calculate_jmp_address</code>  function.</p>\n<p>With that, we've wrapped up the working of the VM! I will leave the actual <em>reversing</em> of this VM as an exercise to the reader. A quick brief on one of the solution approaches:</p>\n<ul>\n<li>Extract the instructions from memory by debugging</li>\n<li>Write a disassembler</li>\n<li>Analyse the disassembly generated (pretty trivial)</li>\n</ul>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>I wanted this to be a one-of-a-kind challenge, since I had never seen many mixed mode samples in CTFs. I hope it served as kind of an intro to mixed mode analysis as well as reversing. And most of all I hope you guys had fun solving the challenge!</p>\n<p>As always, you can always reach out to me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf\">Twitter/X</span> if you have any doubts/suggestions. 😃</p>\n",
            "tags": [
                "Writeup",
                ".NET",
                "Reversing",
                "CTF",
                "Writeup",
                "Mixed-mode"
            ]
        }
    ]
}