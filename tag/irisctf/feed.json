{
    "version": "https://jsonfeed.org/version/1",
    "title": "The Workshop",
    "subtitle": "",
    "icon": "https://the-m3chanic.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://the-m3chanic.github.io",
    "items": [
        {
            "id": "https://the-m3chanic.github.io/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/",
            "url": "https://the-m3chanic.github.io/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/",
            "title": "Secure Computing - Iris CTF 2024 Writeup",
            "date_published": "2024-01-26T01:12:26.000Z",
            "content_html": "<p>Note: My team and I didn't end up solving this during the CTF, we got very close though. This writeup goes through the steps I took to finish solving the challenge after the CTF ended. Hopefully you learn a thing or two ðŸ˜ƒ</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your own secure computer can check the flag! Might have forgotten to add the logic to the program, but I think if you guess enough, you can figure it out. Not sure</span><br></pre></td></tr></table></figure></p>\n<p>The description seems to hint at something related to &quot;secure computing&quot;, and so does the challenge name. Interesting, we shall see.</p>\n<h2 id=\"understanding-the-challenge\"><a class=\"anchor\" href=\"#understanding-the-challenge\">#</a> Understanding the challenge</h2>\n<p>Opening the file up in IDA, we see this</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/IDA_main.png\" alt=\"IDA main\" /></p>\n<p>It's passing our input (flag) as arguments to a syscall, in the form of 6 Qwords.<br />\nCalling syscall <em>0x1337</em> seems a little odd - because it obviously does not <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtb3MvZG9jcy8rL21hc3Rlci9jb25zdGFudHMvc3lzY2FsbHMubWQ=\">exist</span> - so what's going on here?</p>\n<p>A quick google search with select keywords seems to point us in a single direction</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/keyword_search.png\" alt=\"keyword search\" /></p>\n<p>&lt;br&gt;</p>\n<p>The man page of the  <code>seccomp</code>  syscall gives us this<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The seccomp() system call operates on the Secure Computing (seccomp) state </span><br><span class=\"line\">of the calling process.</span><br></pre></td></tr></table></figure><br />\n<strong>What does that mean?</strong></p>\n<h2 id=\"understanding-seccomp\"><a class=\"anchor\" href=\"#understanding-seccomp\">#</a> Understanding Seccomp</h2>\n<p>Seccomp (or Secure Computing) is a security feature in the Linux kernel that provides an additional layer of protection for applications by restricting the system calls that they make. System calls are the interface between user-space applications and the kernel, allowing programs to request services from the operating system.</p>\n<p>Some important (and interesting) features of Seccomp:</p>\n<ul>\n<li>It allows you to define a filter that specifies which system calls are permitted for a particular process. By default, all syscalls are allowed, but with seccomp, you can create a &quot;policy&quot; that restricts this set.</li>\n<li>It uses BPF (Berkeley Packet Filter), which is a virtual machine that can execute a set of instructions to filter system calls. Think of BPF as a &quot;javascript for your kernel&quot;, because it resides in a VM on the kernel and responds to specific events that occur on the system to which it is attached. The filters are written using BPF assembly or even C, which are then compiled to BPF bytecode.</li>\n<li>It offers mainly 2 modes of operation - <em>strict</em> &amp; <em>filter</em>. In strict mode, the process starts with a seccomp filter in place, and any attempt to make an unallowed system call results in the termination of the process. Whereas in filter mode, the filter is applied only when explicitly requested by the process (we will look at the &quot;how&quot; of this later).</li>\n</ul>\n<p>Looking for syscalls with the calling number  <code>317</code>  (seccomp's syscall number), we find this</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/syscall_1337.png\" alt=\"Seccomp syscall\" /></p>\n<p>Hmm, let's look at the arguments passed to it<br />\nThe prototype of the seccomp syscall looks like this:<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syscall(SYS_seccomp, unsigned int operation, unsigned int flags, void *args);</span><br></pre></td></tr></table></figure></p>\n<p>Here, it seems like  <code>operation</code>  is set to 1<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The system calls allowed are defined by a pointer to a Berkeley Packet </span><br><span class=\"line\">Filter (BPF) passed via args.  This argument is a pointer to a struct </span><br><span class=\"line\">sock_fprog; it can be designed to filter arbitrary system calls and </span><br><span class=\"line\">system call arguments.  If the filter is invalid, seccomp() fails,</span><br><span class=\"line\">returning EINVAL in errno.</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In order to use the SECCOMP_SET_MODE_FILTER operation, either the calling </span><br><span class=\"line\">thread must have the CAP_SYS_ADMIN capability in its user namespace, or the </span><br><span class=\"line\">thread must already have the no_new_privs bit set.  If that bit was not </span><br><span class=\"line\">already set by an ancestor of this thread, the thread must make the following</span><br><span class=\"line\">call:</span><br><span class=\"line\"></span><br><span class=\"line\">    prctl(PR_SET_NO_NEW_PRIVS, 1);</span><br></pre></td></tr></table></figure></p>\n<p>Both of these are being done in our binary. Let us see what the man page says about those BPF instructions containing the actual filters for our input, which will allow us to solve the challenge.</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">When adding filters via SECCOMP_SET_MODE_FILTER, args points to a filter</span><br><span class=\"line\">program:</span><br><span class=\"line\"></span><br><span class=\"line\">   struct sock_fprog &#123;</span><br><span class=\"line\">       unsigned short      len;    /* Number of BPF instructions */</span><br><span class=\"line\">       struct sock_filter *filter; /* Pointer to array of</span><br><span class=\"line\">                                      BPF instructions */</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Each program must contain one or more BPF instructions:</span><br><span class=\"line\"></span><br><span class=\"line\">   struct sock_filter &#123;            /* Filter block */</span><br><span class=\"line\">       __u16 code;                 /* Actual filter code */</span><br><span class=\"line\">       __u8  jt;                   /* Jump true */</span><br><span class=\"line\">       __u8  jf;                   /* Jump false */</span><br><span class=\"line\">       __u32 k;                    /* Generic multiuse field */</span><br><span class=\"line\">   &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>Found our instructions!<br />\nSo now our approach would be to extract these instructions and disassemble the BPF bytes to see if we can make sense of the filter and reverse it. But let's see if any tool exists that can already do it for us, just to make our lives a little easier ðŸ˜ƒ</p>\n<p>Another quick google search leads us to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2RhdmlkOTQyai9zZWNjb21wLXRvb2xz\">seccomp-tools</span>, something that exactly matches the description of what we're looking for.</p>\n<p>To extract the filters from the binary, we simply run:<br />\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal</span><br></pre></td></tr></table></figure></p>\n<p>But doing this yields no result, why's that?<br />\nReading the GitHub page of seccomp-tools, we can see this<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dumps the seccomp BPF from an execution file. This work is done by utilizing </span><br><span class=\"line\">the ptrace syscall.</span><br></pre></td></tr></table></figure><br />\nAnd we have a ptrace syscall in our binary, which is obviously causing the issue - so let's patch that out.</p>\n<p>Now running seccomp-tools:<br />\n<img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/seccomp_dump.png\" alt=\"image\" /></p>\n<p>Bingo!</p>\n<p>But one thing we have to keep in mind, is the loop in which  <code>seccomp</code>  is being called. Note that it is not just one filter being set, it is <em>eight</em> of them.</p>\n<p><img data-src=\"/images/post_images/Writeup-Secure-Computing-IRIS-CTF/8-filters.png\" alt=\"image\" /></p>\n<p><code>v0</code>  is acting as the loop constraint here, making it run for 8 times, meaning 8 filters being set.<br />\nTo dump all 8 filters, we can use the  <code>-l</code>  flag with seccomp-tools.<br />\nAnd to clear out all the other garbage being printed along with the output, we can use a little bit of bash.</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal -l 8 | grep -v <span class=\"string\">&quot;=======|CODE&quot;</span> | <span class=\"built_in\">cut</span> -d<span class=\"string\">&quot; &quot;</span> -f7- &gt; disasm.txt</span><br></pre></td></tr></table></figure></p>\n<p>Now that we have all 8 filters in a single file, time to solve for the constraints.</p>\n<h2 id=\"solving-the-challenge\"><a class=\"anchor\" href=\"#solving-the-challenge\">#</a> Solving the challenge</h2>\n<p>Looking at the file (and from the challenge, too), we can see that we'll have 6 QWORDS to input, which it checks and returns  <code>KILL</code>  if it's wrong and  <code>ERRNO(0)</code>  if it's correct.<br />\nFirst thing that comes to mind is z3, so let's go for that.</p>\n<p>Here is my script to parse the file and add constraints and &quot;emulate&quot; the filter on my args</p>\n<p><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># solver</span></span><br><span class=\"line\">s = Solver()</span><br><span class=\"line\">INT_BITS = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">getFlag</span>(<span class=\"params\">model</span>):</span><br><span class=\"line\">    flag = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">        t = model[args[i]].as_long()</span><br><span class=\"line\">        flag += <span class=\"built_in\">bytes</span>.fromhex(<span class=\"built_in\">hex</span>(t)[<span class=\"number\">2</span>:]).decode()[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">        t = model[args2[i]].as_long()</span><br><span class=\"line\">        flag += <span class=\"built_in\">bytes</span>.fromhex(<span class=\"built_in\">hex</span>(t)[<span class=\"number\">2</span>:]).decode()[::-<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;[+] Flag: irisctf&#123;&#123;<span class=\"subst\">&#123;flag&#125;</span>&#125;&#125;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># using BitVecVals instead of python integers because </span></span><br><span class=\"line\"><span class=\"comment\"># they act like a &quot;constant symbol&quot;, and automatically get </span></span><br><span class=\"line\"><span class=\"comment\"># truncated according to size, etc </span></span><br><span class=\"line\">A = BitVecVal(<span class=\"number\">0</span>, INT_BITS)</span><br><span class=\"line\">X = BitVecVal(<span class=\"number\">0</span>, INT_BITS)</span><br><span class=\"line\">sys_number = BitVecVal(<span class=\"number\">0x1337</span>, INT_BITS)</span><br><span class=\"line\">arch = BitVecVal(<span class=\"number\">0xc000003e</span>, INT_BITS)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># splitting our qwords into pairs of dwords, higher and lower </span></span><br><span class=\"line\"><span class=\"comment\"># since bpf uses only 32-bit integers at a maximum anyways </span></span><br><span class=\"line\">args = []</span><br><span class=\"line\">args2 = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># zero initialised since mem is being initialised in the program </span></span><br><span class=\"line\">mem = [<span class=\"number\">0</span>] * <span class=\"number\">16</span></span><br><span class=\"line\">       </span><br><span class=\"line\"><span class=\"comment\"># args is lower DWORD</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    x = BitVec(<span class=\"string\">f&quot;args[<span class=\"subst\">&#123;i&#125;</span>]&quot;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    args.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &gt;= <span class=\"number\">32</span>)</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &lt;=<span class=\"number\">127</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># args2 is higher DWORD </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    x = BitVec(<span class=\"string\">f&quot;args2[<span class=\"subst\">&#123;i&#125;</span>]&quot;</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    args2.append(x)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &lt;= <span class=\"number\">127</span>)</span><br><span class=\"line\">        s.add(Extract(j + <span class=\"number\">7</span>, j, x) &gt;= <span class=\"number\">32</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;disasm.txt&quot;</span>) <span class=\"keyword\">as</span> disassembly:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line_number, line <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(disassembly):</span><br><span class=\"line\">        line = line.strip()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># ignore all return and kill statements, not needed for our solver</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;return&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"string\">&quot; &gt;&gt; &quot;</span> <span class=\"keyword\">in</span> line: <span class=\"comment\"># upper DWORD being extracted</span></span><br><span class=\"line\">            line = line.replace(<span class=\"string\">&quot; &gt;&gt; 32&quot;</span>, <span class=\"string\">&quot;&quot;</span>).replace(<span class=\"string\">&quot;args&quot;</span>, <span class=\"string\">&quot;args2 &quot;</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\"># lines where constraint for our input comes in </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;goto&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            temp_line = line.split()</span><br><span class=\"line\">            lhs = temp_line[<span class=\"number\">1</span>][<span class=\"number\">1</span>:]</span><br><span class=\"line\">            rhs = temp_line[<span class=\"number\">3</span>][:-<span class=\"number\">1</span>]</span><br><span class=\"line\">            rhs = <span class=\"built_in\">eval</span>(rhs)</span><br><span class=\"line\">            s.add(A == rhs)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">exec</span>(line)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># if A is an integer and not a BitVector, make sure it is </span></span><br><span class=\"line\">        <span class=\"comment\"># within the 32-bit limit </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">type</span>(A) == <span class=\"built_in\">int</span>:</span><br><span class=\"line\">            A = A % (<span class=\"number\">2</span> ** INT_BITS)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">assert</span> s.check() == sat</span><br><span class=\"line\">model = s.model()</span><br><span class=\"line\"></span><br><span class=\"line\">getFlag(model)</span><br></pre></td></tr></table></figure></p>\n<p>That's one way to solve it, but one way doesn't cut it, does it?</p>\n<p>After the CTF, I came across <span class=\"exturl\" data-url=\"aHR0cHM6Ly9rbGVlLmdpdGh1Yi5pbw==\">Klee</span>. Klee, you could say, is a Symbolic Virtual Machine (Solver), that allows you to symbolically execute a C source file. This is advantageous for 2 main reasons:</p>\n<ul>\n<li>You don't have to bother about having to convert C source to Python (to have to apply Z3 on it to solve symbolically)</li>\n<li>While converting from C to Python, we don't have to worry about stuff like signedness and typecasting ðŸ˜ƒ</li>\n</ul>\n<p>Klee is a symbolic execution engine that explores program paths symbolically, treating variables as symbols rather than with concrete values. It is built on top of the LLVM compiler infrastructure, so this integration allows it to work easily with programs written in C/C++, and leverage LLVM capabilities for program analysis and transformation.</p>\n<h4 id=\"install-klee\"><a class=\"anchor\" href=\"#install-klee\">#</a> <strong>Install Klee</strong></h4>\n<p>Install <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL2luc3RhbGwv\">Docker</span> (since that is what I used to run Klee on this)</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull klee/klee</span><br><span class=\"line\">docker run --<span class=\"built_in\">rm</span> -ti --<span class=\"built_in\">ulimit</span>=<span class=\"string\">&#x27;stack=-1:-1&#x27;</span> klee/klee</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"convert-c-source-to-bitcode\"><a class=\"anchor\" href=\"#convert-c-source-to-bitcode\">#</a> <strong>Convert C source to Bitcode</strong></h4>\n<p>(Bitcode is the format of code that Klee operates on. It is the LLVM IR representation of the code used by compiler chains like  <code>clang</code> )<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -emit-llvm -c &lt;filename&gt;.c</span><br><span class=\"line\">klee &lt;filename&gt;.bc</span><br></pre></td></tr></table></figure></p>\n<p>This will generate a directory with a number (indicating the number of times you've run Klee on the file so far),  <code>klee-last</code>  is the directory with the information on the file that was last symbolically executed with Klee.</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span> klee-assert/ | grep assert </span><br><span class=\"line\">ktest-tool klee-latest/&lt;files_output_from_previous_command&gt;</span><br></pre></td></tr></table></figure></p>\n<p>The files are output in a format  <code>test&lt;number&gt;.assert.err</code> .</p>\n<p>To run Klee on your C-source, simply run<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ktest-tool klee-last/test&lt;number&gt;.ktest</span><br></pre></td></tr></table></figure></p>\n<p><strong>To generate the filter.c files to run using Klee, you can do the following</strong>:<br />\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seccomp-tools dump ./chal -l 8 &gt; full_disasm.txt</span><br></pre></td></tr></table></figure><br />\n&lt;br&gt;</p>\n<p>Followed by a script to split these files and parse them, then convert them to C files in the format the Klee expects<br />\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># split the large output into 8 separate files properly </span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">split_files</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(filename, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        disassembly = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">    LINES_PER_FILE=<span class=\"number\">3797</span></span><br><span class=\"line\">    i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> disassembly:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i % LINES_PER_FILE == <span class=\"number\">0</span>):</span><br><span class=\"line\">            <span class=\"comment\"># open the next file to disassemble </span></span><br><span class=\"line\">            file_number = i // LINES_PER_FILE</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>):</span><br><span class=\"line\">                f.close()</span><br><span class=\"line\">                f = <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                f = <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;w&quot;</span>)</span><br><span class=\"line\">        f.write(<span class=\"string\">&#x27; &#x27;</span>.join(line.split()[<span class=\"number\">5</span>:]) + <span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        i += <span class=\"number\">1</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">program_head = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdint.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdbool.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &lt;stdlib.h&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#include &lt;assert.h&gt;</span></span><br><span class=\"line\"><span class=\"string\">#include &quot;klee/klee.h&quot;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#define ERRNO(x) (x)</span></span><br><span class=\"line\"><span class=\"string\">#define KILL 2</span></span><br><span class=\"line\"><span class=\"string\">#define ALLOW 1</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#define EM_X86_64 62</span></span><br><span class=\"line\"><span class=\"string\">#define __AUDIT_ARCH_64BIT 0x80000000</span></span><br><span class=\"line\"><span class=\"string\">#define __AUDIT_ARCH_LE 0x40000000</span></span><br><span class=\"line\"><span class=\"string\">#define AUDIT_ARCH_X86_64 (EM_X86_64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">prog_main = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">int main(int argc, char * argv[]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    uint64_t args[6];</span></span><br><span class=\"line\"><span class=\"string\">    klee_make_symbolic(args, sizeof(args), &quot;args&quot;);</span></span><br><span class=\"line\"><span class=\"string\">    uint8_t result = filter(args);</span></span><br><span class=\"line\"><span class=\"string\">    // Did the filter return zero?</span></span><br><span class=\"line\"><span class=\"string\">    klee_assume(result == 0);</span></span><br><span class=\"line\"><span class=\"string\">    // If we reach this point, we found a solution</span></span><br><span class=\"line\"><span class=\"string\">    klee_assert(0);</span></span><br><span class=\"line\"><span class=\"string\">    return 0;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">function_init = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">uint8_t filter(uint64_t args[6]) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // initialize memory and registers</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t A = 0;</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t X = 0;</span></span><br><span class=\"line\"><span class=\"string\">    // fix architecture and syscall number</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t sys_number = 0x1337;</span></span><br><span class=\"line\"><span class=\"string\">    uint32_t arch = AUDIT_ARCH_X86_64;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    uint32_t mem[16] = &#123;0&#125;;</span></span><br><span class=\"line\"><span class=\"string\">    [FUNCTION BODY]</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># return the line number that control flow will go to, given a line</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">goto_target</span>(<span class=\"params\">line: <span class=\"built_in\">str</span></span>):</span><br><span class=\"line\">    line = line.split()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> line[<span class=\"number\">5</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># generate function body </span></span><br><span class=\"line\"><span class=\"comment\"># need to keep track of line number, starting from 1, to insert goto_label into line</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">parse_disassembly</span>(<span class=\"params\">disassembly</span>):    </span><br><span class=\"line\">    c_code = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line_number, line <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(disassembly):</span><br><span class=\"line\">        line_number += <span class=\"number\">1</span>  <span class=\"comment\"># line number is normally zero-indexed</span></span><br><span class=\"line\">        <span class=\"comment\"># if line has a goto statement, most important </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">&quot;goto&quot;</span> <span class=\"keyword\">in</span> line:</span><br><span class=\"line\">            <span class=\"comment\"># store line number and insert &quot;LABEL_&quot; + line_number + &quot;_&quot; in next line </span></span><br><span class=\"line\">            goto_line = goto_target(line)</span><br><span class=\"line\">            <span class=\"comment\"># insert label</span></span><br><span class=\"line\">            c_code += line.replace(<span class=\"built_in\">str</span>(goto_line), <span class=\"string\">f&quot;LABEL_<span class=\"subst\">&#123;goto_line&#125;</span>&quot;</span>)</span><br><span class=\"line\">            c_code += <span class=\"string\">&quot;LABEL_&quot;</span> + goto_line + <span class=\"string\">&quot;: &quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            c_code += line </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> c_code </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">main</span>():</span><br><span class=\"line\">    split_files(<span class=\"string\">&quot;full_disasm.txt&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># iterate through all the disassembly files to parse out </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> file_number <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"number\">8</span>):</span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;disassembly_<span class=\"subst\">&#123;file_number&#125;</span>.txt&quot;</span>, <span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            disassembly = f.readlines()</span><br><span class=\"line\"></span><br><span class=\"line\">        c_code = parse_disassembly(disassembly)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">f&quot;filter_<span class=\"subst\">&#123;file_number&#125;</span>.c&quot;</span>, <span class=\"string\">&quot;w&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">            program = program_head + <span class=\"string\">&quot;\\n\\n&quot;</span> + function_init.replace(<span class=\"string\">&quot;[FUNCTION BODY]&quot;</span>, c_code) + prog_main </span><br><span class=\"line\">            f.write(program)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    main()</span><br></pre></td></tr></table></figure></p>\n<p>All in all, this was a very fun challenge for me to solve - with lots to learn. GGs to the author from IrisSec for making such a unique challenge!</p>\n",
            "tags": [
                "Writeup",
                "Security",
                "Reversing",
                "CTF",
                "IrisCTF"
            ]
        }
    ]
}