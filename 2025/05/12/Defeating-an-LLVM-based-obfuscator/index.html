<!-- build time:Wed Jul 16 2025 18:04:07 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="5zx5xIGOp0FNxcFEvh9Rls0F6vdo4JcDkQNT_PG4ZvQ"><meta name="msvalidate.01" content="330584D871B0D2751FD232BD023460DA"><link rel="alternate" type="application/rss+xml" title="The Workshop" href="https://the-m3chanic.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="The Workshop" href="https://the-m3chanic.github.io/atom.xml"><link rel="alternate" type="application/json" title="The Workshop" href="https://the-m3chanic.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="LLVM,obfuscation,reversing"><link rel="canonical" href="https://the-m3chanic.github.io/2025/05/12/Defeating-an-LLVM-based-obfuscator/"><title>Defeating an LLVM based obfuscator with IDA Pro - Writeup | the.m3chanic = The Workshop</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Defeating an LLVM based obfuscator with IDA Pro</h1><div class="meta"><span class="item" title="Created: 12-05-2025 15:42:39"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2025-05-12T15:42:39Z">12-05-2025</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">the.m3chanic</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax static-grey-bg"><div class="grey-placeholder"></div></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Writeup/" itemprop="item" rel="index" title="In Writeup"><span itemprop="name">Writeup</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="https://the-m3chanic.github.io/2025/05/12/Defeating-an-LLVM-based-obfuscator/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Suraj Kumar"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Workshop"></span><div class="body md" itemprop="articleBody"><h2 id="some-pretext"><a class="anchor" href="#some-pretext">#</a> Some pretext</h2><p>Me, Chandra and Sidharth recently placed 3rd in a Reverse Engineering Hackathon/CTF conducted by <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWl0bS5hYy5pbg==">IIT Madras</span> and <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWlpdGRtLmFjLmlu">IIITDM Kancheepuram</span>. This was very unique as it wasn't like any of the other RE focused CTFs we've played before and the style was really different.</p><p>The entire thing began with a CTF which had all categories you would expect in a normal CTF (RE, Pwn, Web, Forensics). Us being low level guys, managed to get down RE and Pwn, and took a bit of time with Forensics. Sadly Web was too guessy for us ðŸ˜” (blind + skill issue). They froze the scoreboard like 30 mins into the CTF but I figure we qualified since they sent us a mail for the next round.</p><p>After the prelims CTF, I think the top 25-30 teams were picked for the next round. The next round was a RE specific CTF. That one was super easy except for one challenge which was broken, I think. They pushed a fix for it and then we solved that too. So far it was looking pretty normal and we weren't sure what the &quot;hackathon&quot; part of this was.</p><h3 id="what-is-a-hackathon-tho"><a class="anchor" href="#what-is-a-hackathon-tho">#</a> What is a hackathon tho?</h3><p>For context, a Hackathon is a software engineering/development oriented competition wherein teams are given certain topics/themes and guidelines to follow, and they have X amount of time to build a working product or a prototype, which they can then showcase to the judges and based on the judgement received they would get credited a certain number of points.</p><h2 id="defense-phase"><a class="anchor" href="#defense-phase">#</a> Defense phase?</h2><p>So after the 2 prelim rounds of CTFs, 20-25 teams were picked for the Hackathon (aka &quot;Defense&quot;) phase. This is where the uniqueness of the entire thing began. We were given a document that outlined what we would need to do and the specifications we were allowed to use. The entire specification is <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xaUJHZ1NCeUdsRDkxdVdVT3o2QlRtQ1JweEN1N21IMUotcmZyTFBEdFdCRS9lZGl0">here</span>.</p><p>TL;DR</p><ul><li>We are given a <code>main.c</code> file, with 3 sensitive values: <code>key</code> (a 16-byte AES Key), <code>egg_params</code> (a 5x6 array) and a function <code>compute_gf()</code></li><li>Each team is given the same core binary with the above 3 things changed</li><li>You &quot;defend&quot; your binary by obfuscating it such that the 3 sensitive values are hard to recover</li><li>You &quot;attack&quot; other binaries by reversing and getting those 3 values, and submit them as flags</li></ul><p>In the defense phase, we were given criterion to follow with which we were to obfuscate our binaries. These were pretty basic, like:</p><ul><li>No using any off the shelf obfuscators like UPX, CobaltStrike, etc.</li><li>Code must be written by members of our team, and no one else</li><li>The obfuscated binary must be functionally the same as the original, etc.</li></ul><p>Okay.. enough yap<br>This blog is more to focus on one of the challenges made by some folks at <span class="exturl" data-url="aHR0cHM6Ly9pbmZvc2VjaWl0ci5pbg==">InfosecIITR</span>.</p><p>They made an LLVM based obfuscator, and while our challenge was something similar, it followed a different style from theirs. We went for a control flow flattening approach - while they went for more of a instruction overlap approach. It was an easy challenge, but I just wanted to showcase some cool things IDAPython is capable of.</p><h2 id="the-challenge"><a class="anchor" href="#the-challenge">#</a> The Challenge</h2><p>The binary itself had a behaviour exactly the same as the others in the competition - give it plaintext as a command line argument, and it would encrypt it and give it back to you.</p><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apollo@apollo:/mnt/f/Work/CTFs/binary-clash-25/attack-phase/3$ ./3_VMwhere</span><br><span class="line">Invalid Usage!!</span><br><span class="line">Usage: ./encrypt &lt;plain_text&gt;</span><br><span class="line">apollo@apollo:/mnt/f/Work/CTFs/binary-clash-25/attack-phase/3$ ./3_VMwhere hello</span><br><span class="line">Plaintext :: 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">Ciphertext:: a0 6b 44 12 fc bd d2 a0 0c 71 d5 4b ba d6 84 94</span><br><span class="line">Egg 0 : 0x28</span><br><span class="line">Global Flag: 0x77</span><br></pre></td></tr></table></figure><p></p><p>Now, looking at it in IDA, I wouldn't say it was the prettiest binary I've ever seen.<br>If you look for the main function in the normal Linux ELF method (look for <code>start</code> , then find the first argument passed to the function - <code>libc_start_main</code> - which is explicitly called by start), you will first off see that IDA marks it as a location and not a subroutine - meaning that something is off already.</p><p><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image.png" alt="looking at start in IDA Pro"></p><p>And at the location:<br><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image-1.png" alt="disassembly of main"></p><p>That definitely does not look right.</p><p>The <code>jmp</code> at <code>0x40B234</code> definitely looks suspicious, why is it jumping to the address of its own basic block + 5?</p><p>You can press <code>u</code> to undefine code at a given position in IDA, and <code>c</code> to redefine it as code. Let us undefine code starting from <code>0x40B228</code> , and defone code starting at <code>0x40B228 + 5</code> -&gt; <code>0x40B22D</code> , and see where that takes us.</p><p><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image-2.png" alt="hidden jump"></p><p>Looks like the code there is being interpreted as data, we can fix that easily (hit <code>u</code> at that address and then hit <code>c</code> ). Doing so, gives us this</p><p><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image-3.png" alt="hidden jump but fr this time"></p><p>Well well well, what do we have here? A hidden <code>jmp</code> instruction.</p><p>Analysing the code at that location gives us similar looking stuff</p><p><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image-4.png" alt="2nd obfuscation place"></p><p>Applying the same stuff again, gives us the same results, except an instruction before the same old block again</p><p><img data-src="/images/Defeating-an-LLVM-based-obfuscator/image-7.png" alt="jmp which leads to actual stuff"></p><p>Again, with this <code>jmp</code> leading to a similar looking block, i.e:</p><ol><li><code>mov</code> a random 8-byte value into <code>rax</code></li><li><code>xor eax, eax</code></li><li><code>jmp</code> into a location which is 5 bytes ahead of the basic block it belongs to, which will jump to a new location which may/may not have some code there, before it enters the same block again.</li></ol><p>At this point in the competition the pattern was clear to me, and I started figuring out a way to extract just the instructions we need (between the real <code>jmp</code> and before the next obfuscated block). So I settled on writing down an IDAPython script for this, since I work mainly with IDA Pro anyways.</p><p>My idea was this:</p><ol><li>Look for instructions matching the format mentioned above</li><li>If the instruction is found, then find the 5th byte offset from the start of the block, and extract the address of the real <code>jmp</code> from on there</li><li>At the new <code>jmp</code> address, keep reading instructions until you meet the next instruction matching the block</li></ol><p>Rinse. Repeat.</p><p>I wanted to take this as a chance to check out how good IDA's Python API was, and basically take it on a test drive.</p><p>Now I had to write an IDA Script to this (ðŸ—¿), ahem, so we shall do that next</p><p>The IDA Python documentation isn't exactly the best (if someone actually does find something, please hit me up), so I kind of had to rely mostly on <span class="exturl" data-url="aHR0cHM6Ly9ncmVwLmFwcA==">grep.app</span> to see examples of stuff similar to what I want to do.</p><p>Some time of dilly dallying, and I made a rough script to fix up the main function.</p><p></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_ua, idautils, idc, idaapi, ida_bytes, ida_funcs, ida_hexrays, ida_name, ida_idp, ida_segment</span><br><span class="line"><span class="keyword">from</span> ida_ua <span class="keyword">import</span> insn_t</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_map</span>():</span><br><span class="line">    reg_map = &#123;&#125;</span><br><span class="line">    proc = ida_idp.ph.regnames</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, reg_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(proc):</span><br><span class="line">        <span class="keyword">if</span> reg_name:</span><br><span class="line">            reg_map[idx] = reg_name.lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reg_map</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_instruction_at</span>(<span class="params">address</span>):</span><br><span class="line">    insn = idaapi.insn_t()</span><br><span class="line">    length = ida_ua.decode_insn(insn, address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;0x<span class="subst">&#123;address:x&#125;</span>: No valid instruction found&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    mnemonic = insn.get_canon_mnem()</span><br><span class="line"></span><br><span class="line">    disasm = idc.generate_disasm_line(address, <span class="number">0</span>)</span><br><span class="line">    clean_disasm = idaapi.tag_remove(disasm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot; &quot;</span> <span class="keyword">in</span> clean_disasm:</span><br><span class="line">        operand_part = clean_disasm.split(<span class="string">&quot; &quot;</span>, <span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        operand_part = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    bytes_data = ida_bytes.get_bytes(address, length)</span><br><span class="line">    hex_bytes = <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;b:02x&#125;</span>&quot;</span> <span class="keyword">for</span> b <span class="keyword">in</span> bytes_data)</span><br><span class="line"></span><br><span class="line">    hex_bytes = <span class="built_in">bytes</span>.fromhex(hex_bytes)</span><br><span class="line">    <span class="keyword">return</span> address, <span class="built_in">len</span>(hex_bytes), mnemonic, operand_part</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_messed_instruction</span>(<span class="params">call_loc</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    instructions of the type:</span></span><br><span class="line"><span class="string">    mov     rax, 48FFFF08EB0B6754h</span></span><br><span class="line"><span class="string">    xor eax, eax</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> reg_map</span><br><span class="line">    cur_insn = ida_ua.insn_t()</span><br><span class="line">    insn_len = ida_ua.decode_insn(cur_insn, call_loc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> insn_len != <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if it&#x27;s a mov to rax with a large immediate</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> cur_insn.get_canon_mnem() != <span class="string">&#x27;mov&#x27;</span> <span class="keyword">or</span> reg_map[cur_insn.Op1.reg] != <span class="string">&#x27;rax&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        hex_value = <span class="built_in">hex</span>(cur_insn.Op2.value)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">bytes</span>.fromhex(hex_value)) != <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> (KeyError, ValueError):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check the second instruction (xor eax, eax)</span></span><br><span class="line">    next_insn = ida_ua.insn_t()</span><br><span class="line">    next_insn_len = ida_ua.decode_insn(next_insn, call_loc+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> next_insn_len != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> next_insn.get_canon_mnem() != <span class="string">&#x27;xor&#x27;</span> <span class="keyword">or</span> reg_map[next_insn.Op1.reg] != <span class="string">&#x27;rax&#x27;</span> <span class="keyword">or</span> reg_map[next_insn.Op2.reg] != <span class="string">&#x27;rax&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># now we know for sure it is a messed instruction</span></span><br><span class="line">    <span class="comment"># calculate the jump address</span></span><br><span class="line">    jmp_insn = ida_ua.insn_t()</span><br><span class="line">    jmp_insn_len = ida_ua.decode_insn(jmp_insn, call_loc+<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> jmp_insn_len == <span class="number">0</span> <span class="keyword">or</span> jmp_insn.get_canon_mnem() != <span class="string">&#x27;jmp&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># jmp address - return as an integer, not a hex string</span></span><br><span class="line">    jmp_addr = jmp_insn.Op1.addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;jmp_addr = <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>, jmp_addr, jmp_addr - call_loc</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize register map</span></span><br><span class="line">reg_map = get_register_map()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> reg_map:</span><br><span class="line">        reg_map[i] = <span class="string">&#x27;r&#x27;</span> + reg_map[i]</span><br><span class="line"></span><br><span class="line">main_start = <span class="number">0x407EB0</span></span><br><span class="line">curr_addr = main_start</span><br><span class="line">end_addr = <span class="number">0x40AA40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> curr_addr &lt; end_addr:</span><br><span class="line">    result = is_messed_instruction(curr_addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        is_messed, jmp_addr, length = result</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Found messed instruction at <span class="subst">&#123;<span class="built_in">hex</span>(curr_addr)&#125;</span>, jumping to <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># NOP out the bogus instruction </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            idc.patch_byte(curr_addr + i, <span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># skip the next 5 bytes</span></span><br><span class="line">        curr_addr += <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># force create an instruction at the jump address in idb</span></span><br><span class="line">        idc.create_insn(jmp_addr)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decode the instruction at the jump address so we can get the new jump address (chain basically)</span></span><br><span class="line">        jmp_insn = ida_ua.insn_t()</span><br><span class="line">        jmp_insn_len = ida_ua.decode_insn(jmp_insn, jmp_addr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> jmp_insn_len &gt; <span class="number">0</span> <span class="keyword">and</span> jmp_insn.get_canon_mnem() == <span class="string">&#x27;jmp&#x27;</span>:</span><br><span class="line">            jmp_chain_addr = jmp_insn.Op1.addr</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;jmp_chain_addr = <span class="subst">&#123;<span class="built_in">hex</span>(jmp_chain_addr)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># NOP out the bogus instruction</span></span><br><span class="line">            range_len = jmp_chain_addr - jmp_addr</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(range_len):</span><br><span class="line">                idc.patch_byte(jmp_addr + i, <span class="number">0x90</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;No valid jump instruction at <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;No messed instruction found at <span class="subst">&#123;<span class="built_in">hex</span>(curr_addr)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p></p><p>Soon after this, I wanted to fix up the entire binary - whichever functions were being called that is. So I went with a DFS approach.<br>From main, make a list of all the functions being called from inside it. Subsequently, add those to the &quot;deobfuscation&quot; queue. Likewise, keep going until there are no functions left.</p><p>Also one annoying thing is inside IDA's API, all the instructions and registers are stored using codes instead of their actual names. I found that the method I've used in my script works for most cases.</p><p></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_ua, idautils, idc, idaapi, ida_bytes, ida_funcs, ida_hexrays, ida_name, ida_idp, ida_segment</span><br><span class="line"><span class="keyword">from</span> ida_ua <span class="keyword">import</span> insn_t</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_register_map</span>():</span><br><span class="line">    reg_map = &#123;&#125;</span><br><span class="line">    proc = ida_idp.ph.regnames</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx, reg_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(proc):</span><br><span class="line">        <span class="keyword">if</span> reg_name:</span><br><span class="line">            reg_map[idx] = reg_name.lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reg_map</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_instruction_at</span>(<span class="params">address</span>):</span><br><span class="line">    insn = idaapi.insn_t()</span><br><span class="line">    length = ida_ua.decode_insn(insn, address)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;0x<span class="subst">&#123;address:x&#125;</span>: No valid instruction found&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    mnemonic = insn.get_canon_mnem()</span><br><span class="line"></span><br><span class="line">    disasm = idc.generate_disasm_line(address, <span class="number">0</span>)</span><br><span class="line">    clean_disasm = idaapi.tag_remove(disasm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot; &quot;</span> <span class="keyword">in</span> clean_disasm:</span><br><span class="line">        operand_part = clean_disasm.split(<span class="string">&quot; &quot;</span>, <span class="number">1</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        operand_part = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    bytes_data = ida_bytes.get_bytes(address, length)</span><br><span class="line">    hex_bytes = <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;b:02x&#125;</span>&quot;</span> <span class="keyword">for</span> b <span class="keyword">in</span> bytes_data)</span><br><span class="line"></span><br><span class="line">    hex_bytes = <span class="built_in">bytes</span>.fromhex(hex_bytes)</span><br><span class="line">    <span class="keyword">return</span> address, <span class="built_in">len</span>(hex_bytes), mnemonic, operand_part</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_messed_instruction</span>(<span class="params">call_loc</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    instructions of the type:</span></span><br><span class="line"><span class="string">    mov     rax, 48FFFF08EB0B6754h</span></span><br><span class="line"><span class="string">    xor eax, eax</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> reg_map</span><br><span class="line">    cur_insn = ida_ua.insn_t()</span><br><span class="line">    insn_len = ida_ua.decode_insn(cur_insn, call_loc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> insn_len != <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if it&#x27;s a mov to rax with a large immediate</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> cur_insn.get_canon_mnem() != <span class="string">&#x27;mov&#x27;</span> <span class="keyword">or</span> reg_map[cur_insn.Op1.reg] != <span class="string">&#x27;rax&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        hex_value = <span class="built_in">hex</span>(cur_insn.Op2.value)[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">bytes</span>.fromhex(hex_value)) != <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> (KeyError, ValueError):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># check the second instruction (xor eax, eax)</span></span><br><span class="line">    next_insn = ida_ua.insn_t()</span><br><span class="line">    next_insn_len = ida_ua.decode_insn(next_insn, call_loc+<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> next_insn_len != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> next_insn.get_canon_mnem() != <span class="string">&#x27;xor&#x27;</span> <span class="keyword">or</span> reg_map[next_insn.Op1.reg] != <span class="string">&#x27;rax&#x27;</span> <span class="keyword">or</span> reg_map[next_insn.Op2.reg] != <span class="string">&#x27;rax&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># now we know for sure it is a messed instruction</span></span><br><span class="line">    <span class="comment"># calculate the jump address</span></span><br><span class="line">    jmp_insn = ida_ua.insn_t()</span><br><span class="line">    jmp_insn_len = ida_ua.decode_insn(jmp_insn, call_loc+<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> jmp_insn_len == <span class="number">0</span> <span class="keyword">or</span> jmp_insn.get_canon_mnem() != <span class="string">&#x27;jmp&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># jmp address - return as an integer, not a hex string</span></span><br><span class="line">    jmp_addr = jmp_insn.Op1.addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;jmp_addr = <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span>, jmp_addr, jmp_addr - call_loc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deobfuscate_function</span>(<span class="params">start_addr, end_addr=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    deobfuscate a function from start_addr to end_addr.</span></span><br><span class="line"><span class="string">    if end_addr is not provided, use the function&#x27;s end address.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Deobfuscating function at <span class="subst">&#123;<span class="built_in">hex</span>(start_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># if end_addr is not provided, try to get it from IDA</span></span><br><span class="line">    <span class="keyword">if</span> end_addr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        func = ida_funcs.get_func(start_addr)</span><br><span class="line">        <span class="keyword">if</span> func:</span><br><span class="line">            end_addr = func.end_ea</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Warning: Could not determine end address for function at <span class="subst">&#123;<span class="built_in">hex</span>(start_addr)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># try to find the next function and use its start as our end</span></span><br><span class="line">            next_func = ida_funcs.get_next_func(start_addr)</span><br><span class="line">            <span class="keyword">if</span> next_func:</span><br><span class="line">                end_addr = next_func.start_ea</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Error: Cannot determine end address for function at <span class="subst">&#123;<span class="built_in">hex</span>(start_addr)&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;function bounds: <span class="subst">&#123;<span class="built_in">hex</span>(start_addr)&#125;</span> - <span class="subst">&#123;<span class="built_in">hex</span>(end_addr)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># queue for functions to deobfuscate (DFS)</span></span><br><span class="line">    functions_to_process = []</span><br><span class="line">    </span><br><span class="line">    curr_addr = start_addr</span><br><span class="line">    <span class="keyword">while</span> curr_addr &lt; end_addr:</span><br><span class="line">        <span class="comment"># check if it&#x27;s a &quot;messed&quot; instruction</span></span><br><span class="line">        result = is_messed_instruction(curr_addr)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            is_messed, jmp_addr, length = result</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Found messed instruction at <span class="subst">&#123;<span class="built_in">hex</span>(curr_addr)&#125;</span>, jumping to <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># NOP out the bogus instruction </span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">                idc.patch_byte(curr_addr + i, <span class="number">0x90</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># skip the next 5 bytes</span></span><br><span class="line">            curr_addr += <span class="number">5</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># force create an instruction at the jump address in IDB</span></span><br><span class="line">            idc.create_insn(jmp_addr)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># decode the instruction at the jump address so we can get the new jump address (chain basically)</span></span><br><span class="line">            jmp_insn = ida_ua.insn_t()</span><br><span class="line">            jmp_insn_len = ida_ua.decode_insn(jmp_insn, jmp_addr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> jmp_insn_len &gt; <span class="number">0</span> <span class="keyword">and</span> jmp_insn.get_canon_mnem() == <span class="string">&#x27;jmp&#x27;</span>:</span><br><span class="line">                jmp_chain_addr = jmp_insn.Op1.addr</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;jmp_chain_addr = <span class="subst">&#123;<span class="built_in">hex</span>(jmp_chain_addr)&#125;</span>&quot;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># NOP out the bogus instruction</span></span><br><span class="line">                range_len = jmp_chain_addr - jmp_addr</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(range_len):</span><br><span class="line">                    idc.patch_byte(jmp_addr + i, <span class="number">0x90</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;No valid jump instruction at <span class="subst">&#123;<span class="built_in">hex</span>(jmp_addr)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># check if it&#x27;s a call instruction</span></span><br><span class="line">            insn = ida_ua.insn_t()</span><br><span class="line">            insn_len = ida_ua.decode_insn(insn, curr_addr)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> insn_len &gt; <span class="number">0</span> <span class="keyword">and</span> insn.get_canon_mnem() == <span class="string">&#x27;call&#x27;</span>:</span><br><span class="line">                <span class="comment"># get the callee</span></span><br><span class="line">                <span class="keyword">if</span> insn.Op1.<span class="built_in">type</span> == ida_ua.o_near:</span><br><span class="line">                    call_target = insn.Op1.addr</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Found call at <span class="subst">&#123;<span class="built_in">hex</span>(curr_addr)&#125;</span> to <span class="subst">&#123;<span class="built_in">hex</span>(call_target)&#125;</span>&quot;</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># add the target to our list of functions to process</span></span><br><span class="line">                    <span class="keyword">if</span> call_target <span class="keyword">not</span> <span class="keyword">in</span> [f[<span class="number">0</span>] <span class="keyword">for</span> f <span class="keyword">in</span> functions_to_process]:</span><br><span class="line">                        <span class="comment"># check if it&#x27;s a valid function</span></span><br><span class="line">                        func = ida_funcs.get_func(call_target)</span><br><span class="line">                        <span class="keyword">if</span> func:</span><br><span class="line">                            functions_to_process.append((call_target, func.end_ea))</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="comment"># try and  create a function</span></span><br><span class="line">                            <span class="keyword">if</span> ida_funcs.add_func(call_target):</span><br><span class="line">                                func = ida_funcs.get_func(call_target)</span><br><span class="line">                                <span class="keyword">if</span> func:</span><br><span class="line">                                    functions_to_process.append((call_target, func.end_ea))</span><br><span class="line">                                <span class="keyword">else</span>:</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">f&quot;Warning: Could not create function at <span class="subst">&#123;<span class="built_in">hex</span>(call_target)&#125;</span>&quot;</span>)</span><br><span class="line">                                    <span class="comment"># still add it to the queue, we&#x27;ll try to determine bounds later</span></span><br><span class="line">                                    functions_to_process.append((call_target, <span class="literal">None</span>))</span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">f&quot;Warning: Could not create function at <span class="subst">&#123;<span class="built_in">hex</span>(call_target)&#125;</span>&quot;</span>)</span><br><span class="line">                                <span class="comment"># still add it to the queue, we&#x27;ll try to determine bounds later</span></span><br><span class="line">                                functions_to_process.append((call_target, <span class="literal">None</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> insn_len &gt; <span class="number">0</span>:</span><br><span class="line">                curr_addr += insn_len</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curr_addr += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> functions_to_process</span><br><span class="line"></span><br><span class="line">reg_map = get_register_map()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> reg_map:</span><br><span class="line">        reg_map[i] = <span class="string">&#x27;r&#x27;</span> + reg_map[i]</span><br><span class="line"></span><br><span class="line">main_start = <span class="number">0x40B220</span></span><br><span class="line">main_end = <span class="number">0x40BC20</span></span><br><span class="line"></span><br><span class="line">processed_functions = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">function_queue = deque([(main_start, main_end)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> function_queue:</span><br><span class="line">    start_addr, end_addr = function_queue.popleft()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> start_addr <span class="keyword">in</span> processed_functions:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># mark the function as processed if not alr processed </span></span><br><span class="line">    processed_functions.add(start_addr)</span><br><span class="line">    </span><br><span class="line">    new_functions = deobfuscate_function(start_addr, end_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add new functions to the queue</span></span><br><span class="line">    <span class="keyword">if</span> new_functions:</span><br><span class="line">        <span class="keyword">for</span> func_start, func_end <span class="keyword">in</span> new_functions:</span><br><span class="line">            <span class="keyword">if</span> func_start <span class="keyword">not</span> <span class="keyword">in</span> processed_functions:</span><br><span class="line">                function_queue.append((func_start, func_end))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;deobfuscation complete, processed <span class="subst">&#123;<span class="built_in">len</span>(processed_functions)&#125;</span> functions&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p><p>This will fix up the entire binary, although you might have to manually fix up some function boundaries by yourself. You can do that by right clicking anywhere inside the function/subroutine already defined.</p><p>The script is kinda massive but I tried my best to make it as clean as possible so I can reuse parts of it later, hopefully someone shows me some goated IDA Python script snippets that are out there somewhere ðŸ™</p><p>Thank you for reading this super-hurried post! If you have any questions or if I have made any errors, please reach out to me on <span class="exturl" data-url="aHR0cHM6Ly94LmNvbS90aGVfbTNjaGFuaWNf">Twitter/X</span> ðŸ˜„</p><div class="tags"><a href="/tags/LLVM/" rel="tag"><i class="ic i-tag"></i> LLVM</a> <a href="/tags/obfuscation/" rel="tag"><i class="ic i-tag"></i> obfuscation</a> <a href="/tags/reversing/" rel="tag"><i class="ic i-tag"></i> reversing</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 28-05-2025 18:41:11" itemprop="dateModified" datetime="2025-05-28T18:41:11Z">28-05-2025</time></span></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>Suraj Kumar <i class="ic i-at"><em>@</em></i>The Workshop</li><li class="link"><strong>Post link: </strong><a href="https://the-m3chanic.github.io/2025/05/12/Defeating-an-LLVM-based-obfuscator/" title="Defeating an LLVM based obfuscator with IDA Pro">https://the-m3chanic.github.io/2025/05/12/Defeating-an-LLVM-based-obfuscator/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/08/25/GSoC-Final-Report/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;post_covers&#x2F;gsoc-final-report.jpg" title="GSoC - Final Report"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> GSoC</span><h3>GSoC - Final Report</h3></a></div><div class="item right"><a href="/2025/07/16/avernos-bi0s-CTF-2025/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;post_covers&#x2F;avernos.jpg" title="avernos - bi0s CTF 2025"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Writeup</span><h3>avernos - bi0s CTF 2025</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#some-pretext"><span class="toc-number">1.</span> <span class="toc-text">Some pretext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#what-is-a-hackathon-tho"><span class="toc-number">1.1.</span> <span class="toc-text">What is a hackathon tho?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defense-phase"><span class="toc-number">2.</span> <span class="toc-text">Defense phase?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#the-challenge"><span class="toc-number">3.</span> <span class="toc-text">The Challenge</span></a></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/" rel="bookmark" title="Secure Computing - Iris CTF 2024 Writeup">Secure Computing - Iris CTF 2024 Writeup</a></li><li><a href="/2024/02/26/Writeup-beehive-bi0sCTF-2024/" rel="bookmark" title="Writeup - beehive - bi0sCTF 2024">Writeup - beehive - bi0sCTF 2024</a></li><li><a href="/2024/02/26/Writeup-t0y-b0x-bi0sCTF-2024/" rel="bookmark" title="Writeup - t0y-b0x - bi0sCTF 2024">Writeup - t0y-b0x - bi0sCTF 2024</a></li><li><a href="/2024/07/07/Writeup-lost-canary-UIUCTF24/" rel="bookmark" title="Writeup - lost canary - UIUCTF24">Writeup - lost canary - UIUCTF24</a></li><li class="active"><a href="/2025/05/12/Defeating-an-LLVM-based-obfuscator/" rel="bookmark" title="Defeating an LLVM based obfuscator with IDA Pro">Defeating an LLVM based obfuscator with IDA Pro</a></li><li><a href="/2025/07/16/avernos-bi0s-CTF-2025/" rel="bookmark" title="avernos - bi0s CTF 2025">avernos - bi0s CTF 2025</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Suraj Kumar" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Suraj Kumar</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">9</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span> <span class="name">categories</span></a></div><div class="item tags"><a href="/tags/"><span class="count">20</span> <span class="name">tags</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZS1tM2NoYW5pYw==" title="https:&#x2F;&#x2F;github.com&#x2F;the-m3chanic"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS90aGVfbTNjaGFuaWNf" title="https:&#x2F;&#x2F;twitter.com&#x2F;the_m3chanic_"><i class="ic i-twitter"></i></span> <span class="exturl item linkedin" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL3RoZS1tM2NoYW5pYw==" title="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;the-m3chanic"><i class="ic i-linkedin"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/08/25/GSoC-Final-Report/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/07/16/avernos-bi0s-CTF-2025/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2024/07/07/Writeup-lost-canary-UIUCTF24/" title="Writeup - lost canary - UIUCTF24">Writeup - lost canary - UIUCTF24</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Technical/" title="In Technical">Technical</a></div><span><a href="/2024/05/08/R2R-Ready-to-Run-Stomping-WTF/" title="R2R (Ready to Run) Stomping - WTF?">R2R (Ready to Run) Stomping - WTF?</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2025/07/16/avernos-bi0s-CTF-2025/" title="avernos - bi0s CTF 2025">avernos - bi0s CTF 2025</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2024/02/26/Writeup-beehive-bi0sCTF-2024/" title="Writeup - beehive - bi0sCTF 2024">Writeup - beehive - bi0sCTF 2024</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2025/05/12/Defeating-an-LLVM-based-obfuscator/" title="Defeating an LLVM based obfuscator with IDA Pro">Defeating an LLVM based obfuscator with IDA Pro</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/GSoC/" title="In GSoC">GSoC</a></div><span><a href="/2024/06/06/GSoC-with-RTEMS-1/" title="GSoC with RTEMS! - 1&#x2F;n">GSoC with RTEMS! - 1/n</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2024/01/26/Writeup-Secure-Computing-IRIS-CTF-2024/" title="Secure Computing - Iris CTF 2024 Writeup">Secure Computing - Iris CTF 2024 Writeup</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/GSoC/" title="In GSoC">GSoC</a></div><span><a href="/2024/08/25/GSoC-Final-Report/" title="GSoC - Final Report">GSoC - Final Report</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Writeup/" title="In Writeup">Writeup</a></div><span><a href="/2024/02/26/Writeup-t0y-b0x-bi0sCTF-2024/" title="Writeup - t0y-b0x - bi0sCTF 2024">Writeup - t0y-b0x - bi0sCTF 2024</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 â€“ <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Suraj Kumar @ the.m3chanic</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/05/12/Defeating-an-LLVM-based-obfuscator/",favicon:{show:"ï¼ˆâ—Â´3ï½€â—ï¼‰:)",hide:"(Â´Ð”ï½€) :("},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->